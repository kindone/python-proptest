{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"python-proptest","text":"<p><code>python-proptest</code> is a property-based testing (PBT) framework for Python, drawing inspiration from libraries such as Haskell's QuickCheck and Python's Hypothesis. Property-based testing shifts the focus from example-based verification to defining universal properties or invariants that must hold true for an input domain.</p> <p>python-proptest provides seamless integration with pytest through the <code>@for_all</code> decorator, automatically detecting pytest context and adapting behavior accordingly.</p> <p>Instead of manually crafting test cases for specific inputs, PBT allows you to describe the domain of inputs your function expects and the general characteristics of the output (e.g., <code>add(a, b)</code> should always be greater than or equal to <code>a</code> and <code>b</code> if they are non-negative). PBT then generates hundreds or thousands of varied inputs, searching for edge cases or unexpected behaviors that violate your defined properties. This approach significantly increases test coverage and the likelihood of finding subtle bugs.</p> <p>The core workflow involves:</p> <ol> <li>Defining a property: A function that takes generated inputs and asserts an expected invariant. See Properties.</li> <li>Specifying generators: Mechanisms for creating random data conforming to certain types or constraints, often built by composing simpler generators using combinators. See Generators and Combinators.</li> <li>Execution: <code>python-proptest</code> automatically runs the property function against numerous generated inputs (typically 100+).</li> <li>Shrinking: If a test case fails (the property returns <code>false</code> or throws), <code>python-proptest</code> attempts to find a minimal counterexample by simplifying the failing input. See Shrinking.</li> <li>Enhanced testing: Use decorators like <code>@example</code>, <code>@settings</code>, and <code>@matrix</code> for specific test cases, configuration, and exhaustive testing. See Decorators.</li> </ol> <p>Consider verifying a round-trip property for a custom parser/serializer:</p> <pre><code>import json\nfrom python_proptest import run_for_all, Gen\n\ndef test_serialize_parse_roundtrip():\n    \"\"\"Test that serializing and parsing preserves data.\"\"\"\n    # Generator for keys (non-empty strings without special characters)\n    key_gen = Gen.str(min_length=1, max_length=10).filter(\n        lambda s: s and '&amp;' not in s and '=' not in s\n    )\n    # Generator for arbitrary string values\n    value_gen = Gen.str(min_length=0, max_length=10)\n    # Generator for dictionaries with our specific keys and values\n    data_object_gen = Gen.dict(key_gen, value_gen, min_size=0, max_size=10)\n\n    # Simple lambda-based property - perfect for run_for_all\n    result = run_for_all(\n        lambda original_data: json.loads(json.dumps(original_data)) == original_data,\n        data_object_gen\n    )\n    assert result is True\n</code></pre> <p>This PBT approach facilitates the discovery of edge cases and intricate bugs that might be neglected by traditional, example-driven testing methodologies.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<p>To add <code>python-proptest</code> to your project, run the following command:</p> <pre><code>pip install python-proptest\n</code></pre> <p>For development dependencies:</p> <pre><code>pip install python-proptest[dev]\n</code></pre>"},{"location":"#core-concepts-and-features","title":"Core Concepts and Features","text":"<p>Understanding these key components will help you use <code>python-proptest</code> effectively:</p> <ul> <li> <p>Generators: Produce random data of various types (primitives, containers) according to specified constraints (e.g., <code>Gen.int()</code>, <code>Gen.list(...)</code>). Learn how to create the basic building blocks of your test data.</p> </li> <li> <p>Combinators: Modify or combine existing generators to create new ones. Discover techniques to constraint, combine, and transform generators for complex data structures.</p> </li> <li> <p>Properties (<code>Property</code>, <code>run_for_all</code>): Express conditions or invariants that should hold true for generated data. <code>python-proptest</code> runs these properties against many generated examples using the <code>run_for_all</code> function or <code>Property</code> class methods. Understand how to define the invariants your code should satisfy and how to run tests.</p> </li> <li> <p>Shrinking: When a property fails, <code>python-proptest</code> attempts to find a minimal counterexample by simplifying the failing input using logic associated with the generated value (often via a <code>Shrinkable</code> structure). See how <code>python-proptest</code> helps pinpoint failures.</p> </li> <li> <p>Stateful Testing: Go beyond simple input-output functions and test systems with internal state by generating sequences of operations or commands. Learn how to model and verify stateful behaviors.</p> </li> </ul>"},{"location":"#api-overview","title":"API Overview","text":"<p>python-proptest provides two main approaches for property-based testing:</p>"},{"location":"#available-generators","title":"Available Generators","text":"<p>Primitive Generators:</p> <ul> <li><code>Gen.int(min_value, max_value)</code> - Random integers</li> <li><code>Gen.float(min_value, max_value)</code> - Random floats</li> <li><code>Gen.bool(true_prob)</code> - Random booleans with configurable probability</li> <li><code>Gen.str(min_length, max_length)</code> - Random strings (ASCII)</li> <li><code>Gen.ascii_string(min_length, max_length)</code> - ASCII strings (0-127)</li> <li><code>Gen.printable_ascii_string(min_length, max_length)</code> - Printable ASCII strings (32-126)</li> <li><code>Gen.unicode_string(min_length, max_length)</code> - Unicode strings</li> <li><code>Gen.ascii_char()</code> - ASCII character codes (0-127)</li> <li><code>Gen.unicode_char()</code> - Unicode character codes (avoiding surrogate pairs)</li> <li><code>Gen.printable_ascii_char()</code> - Printable ASCII character codes (32-126)</li> <li><code>Gen.in_range(min_value, max_value)</code> - Integers in range [min, max) (exclusive)</li> <li><code>Gen.interval(min_value, max_value)</code> - Integers in range [min, max] (inclusive)</li> <li><code>Gen.integers(min_value, max_value)</code> - Alias for interval</li> </ul> <p>Container Generators:</p> <ul> <li><code>Gen.list(element_gen, min_length, max_length)</code> - Lists</li> <li><code>Gen.unique_list(element_gen, min_length, max_length)</code> - Lists with unique elements (sorted)</li> <li><code>Gen.set(element_gen, min_size, max_size)</code> - Sets</li> <li><code>Gen.dict(key_gen, value_gen, min_size, max_size)</code> - Dictionaries</li> <li><code>Gen.tuple(*generators)</code> - Fixed-size tuples</li> </ul> <p>Special Generators:</p> <ul> <li><code>Gen.just(value)</code> - Always generates the same value</li> <li><code>Gen.lazy(func)</code> - Defers evaluation until generation</li> <li><code>Gen.construct(Type, *generators)</code> - Creates class instances</li> </ul> <p>Dependent Generation Combinators:</p> <ul> <li><code>Gen.chain(base_gen, gen_factory)</code> / <code>generator.chain(gen_factory)</code> - Creates dependent tuples</li> <li><code>Gen.aggregate(initial_gen, gen_factory, min_size, max_size)</code> / <code>generator.aggregate(...)</code> - Generates list with dependent elements</li> <li><code>Gen.accumulate(initial_gen, gen_factory, min_size, max_size)</code> / <code>generator.accumulate(...)</code> - Generates final value after dependent steps</li> </ul> <p>Selection Combinators:</p> <ul> <li><code>Gen.one_of(*generators)</code> - Randomly chooses from multiple generators</li> <li><code>Gen.element_of(*values)</code> - Randomly chooses from multiple values</li> <li><code>Gen.weighted_gen(generator, weight)</code> - Wraps generator with weight for one_of</li> <li><code>Gen.weighted_value(value, weight)</code> - Wraps value with weight for element_of</li> </ul> <p>Transformation Combinators:</p> <ul> <li><code>generator.map(func)</code> - Transforms generated values</li> <li><code>generator.filter(predicate)</code> - Filters values by predicate</li> <li><code>generator.flat_map(func)</code> - Creates dependent generators</li> </ul> <p>Decorators:</p> <ul> <li><code>@for_all(*generators, num_runs, seed)</code> - Core property-based testing decorator</li> <li><code>@example(*values)</code> - Provides specific example values to test</li> <li><code>@settings(num_runs, seed)</code> - Configures test parameters</li> <li><code>@matrix(**kwargs)</code> - Provides exhaustive Cartesian product testing</li> </ul>"},{"location":"#1-function-based-approach-works-with-both-pytest-and-unittest","title":"1. Function-based Approach (Works with both pytest and unittest)","text":"<pre><code>from python_proptest import run_for_all, Gen\n\ndef test_addition_commutativity():\n    def property_func(x: int, y: int):\n        return x + y == y + x\n\n    run_for_all(property_func, Gen.int(), Gen.int())\n</code></pre>"},{"location":"#2-decorator-based-approach","title":"2. Decorator-based Approach","text":"<pre><code>from python_proptest import for_all, Gen, example, settings, matrix\n\n@for_all(Gen.int(), Gen.int())\n@matrix(x=[0, 1], y=[0, 1])  # Test edge cases exhaustively\n@example(42, 24)             # Test specific known values\n@settings(num_runs=50, seed=42)  # Configure test parameters\ndef test_addition_commutativity(x: int, y: int):\n    assert x + y == y + x\n\n# Run the test\ntest_addition_commutativity()\n</code></pre>"},{"location":"#3-framework-integration","title":"3. Framework Integration","text":"<p>The <code>@for_all</code> decorator integrates with both pytest and unittest using direct decoration:</p> <p>Pytest Integration: <pre><code>import pytest\nfrom python_proptest import for_all, Gen\n\nclass TestMathProperties:\n    @for_all(Gen.int(), Gen.int())\n    def test_addition_commutativity(self, x: int, y: int):\n        \"\"\"Test that addition is commutative - direct decoration.\"\"\"\n        assert x + y == y + x\n</code></pre></p> <p>Unittest Integration: <pre><code>import unittest\nfrom python_proptest import for_all, Gen\n\nclass TestMathProperties(unittest.TestCase):\n    @for_all(Gen.int(), Gen.int())\n    def test_addition_commutativity(self, x: int, y: int):\n        \"\"\"Test that addition is commutative - direct decoration.\"\"\"\n        self.assertEqual(x + y, y + x)\n</code></pre></p>"},{"location":"#choosing-the-right-approach","title":"Choosing the Right Approach","text":"<p>python-proptest provides multiple approaches for defining property tests. Choose based on your needs:</p>"},{"location":"#use-run_for_all-function-for-simple-lambda-based-tests","title":"Use <code>run_for_all</code> Function for Simple Lambda-Based Tests","text":"<p>Suitable for simple property checks that can be expressed as lambdas:</p> <pre><code>from python_proptest import run_for_all, Gen\n\ndef test_simple_properties():\n    # Type checks\n    result = run_for_all(\n        lambda x: isinstance(x, int),\n        Gen.int(min_value=0, max_value=100)\n    )\n\n    # Range validations\n    result = run_for_all(\n        lambda x: 0 &lt;= x &lt;= 100,\n        Gen.int(min_value=0, max_value=100)\n    )\n\n    # Simple assertions\n    result = run_for_all(\n        lambda lst: all(isinstance(x, int) for x in lst),\n        Gen.list(Gen.int())\n    )\n</code></pre>"},{"location":"#use-run_for_all-decorator-for-complex-generators","title":"Use <code>@run_for_all</code> Decorator for Complex Generators","text":"<p>Perfect for working with <code>chain</code>, <code>aggregate</code>, and <code>accumulate</code> combinators:</p> <pre><code>from python_proptest import run_for_all, Gen\nimport unittest\n\nclass TestDependencies(unittest.TestCase):\n    def test_chain_dependency(self):\n        gen = Gen.chain(Gen.int(1, 10), lambda x: Gen.int(x, x + 10))\n\n        @run_for_all(gen, num_runs=50)\n        def check_dependency(pair):\n            base, dependent = pair\n            self.assertGreaterEqual(dependent, base)\n            self.assertLessEqual(dependent, base + 10)\n        # Auto-executes when decorated!\n\n    def test_aggregate_sequence(self):\n        gen = Gen.aggregate(\n            Gen.int(0, 10),\n            lambda n: Gen.int(n, n + 5),\n            min_size=5, max_size=10\n        )\n\n        @run_for_all(gen, num_runs=30)\n        def check_increasing(values):\n            for i in range(1, len(values)):\n                self.assertGreaterEqual(values[i], values[i - 1])\n</code></pre>"},{"location":"#use-for_all-for-independent-generators","title":"Use <code>@for_all</code> for Independent Generators","text":"<p>Suitable for complex assertions with multiple independent parameters:</p> <pre><code>from python_proptest import for_all, Gen\n\n@for_all(Gen.int(), Gen.int())\ndef test_complex_math_property(x: int, y: int):\n    \"\"\"Test complex mathematical property with multiple conditions.\"\"\"\n    result = x * y + x + y\n    assert result &gt;= x\n    assert result &gt;= y\n    assert result % 2 == (x + y) % 2\n\n@for_all(Gen.str(), Gen.str())\ndef test_string_operations(s1: str, s2: str):\n    \"\"\"Test string operations with multiple assertions.\"\"\"\n    combined = s1 + s2\n    assert len(combined) == len(s1) + len(s2)\n    assert combined.startswith(s1)\n    assert combined.endswith(s2)\n</code></pre>"},{"location":"#guidelines","title":"Guidelines","text":"<ul> <li>Use <code>run_for_all</code> function for simple property checks with lambdas</li> <li>Use <code>@run_for_all</code> decorator for complex generators (<code>chain</code>, <code>aggregate</code>, <code>accumulate</code>) with auto-execution</li> <li>Use <code>@for_all</code> for complex assertions with multiple independent parameters</li> <li>Use <code>run_for_all</code> for seed-based reproducibility testing</li> <li>Use <code>@run_for_all</code> when you want the property test to execute immediately in nested contexts</li> </ul> <p>All approaches provide the same functionality - choose based on your testing framework and preferences. For more details on decorators, see Decorators. For framework integration, see Pytest Integration, Unittest Integration, and Pytest Best Practices.</p>"},{"location":"DEPLOYMENT/","title":"Documentation Deployment","text":"<p>This document explains how the documentation is deployed to GitHub Pages.</p>"},{"location":"DEPLOYMENT/#local-development","title":"Local Development","text":"<p>To work on documentation locally:</p> <pre><code># Set up documentation environment\n./scripts/setup-docs.sh\n\n# Build documentation\nmake docs-build\n\n# Serve documentation locally\nmake docs-serve\n# Open http://127.0.0.1:8000/python-proptest/ in your browser\n</code></pre>"},{"location":"DEPLOYMENT/#github-pages-deployment","title":"GitHub Pages Deployment","text":"<p>The documentation is automatically deployed to GitHub Pages using GitHub Actions when changes are pushed to the <code>main</code> branch.</p>"},{"location":"DEPLOYMENT/#deployment-process","title":"Deployment Process","text":"<ol> <li>Trigger: Push to <code>main</code> branch</li> <li>Build: Install dependencies and build documentation with <code>mkdocs build</code></li> <li>Deploy: Use <code>mkdocs gh-deploy --force</code> to deploy to GitHub Pages</li> <li>Result: Documentation available at https://kindone.github.io/python-proptest/</li> </ol>"},{"location":"DEPLOYMENT/#key-configuration","title":"Key Configuration","text":"<ul> <li>Theme: Material theme with proper navigation</li> <li>Site URL: https://kindone.github.io/python-proptest/</li> <li>Repository: kindone/python-proptest</li> <li>Branch: gh-pages (automatically created)</li> </ul>"},{"location":"DEPLOYMENT/#troubleshooting","title":"Troubleshooting","text":"<p>If the documentation appears as a single page without navigation:</p> <ol> <li>Check theme installation: Ensure <code>mkdocs-material</code> is installed</li> <li>Verify navigation: Check that <code>nav</code> section in <code>mkdocs.yml</code> is correct</li> <li>Clear cache: GitHub Pages may cache old versions</li> <li>Check deployment: Ensure <code>mkdocs gh-deploy</code> is used, not manual file copying</li> </ol>"},{"location":"DEPLOYMENT/#manual-deployment","title":"Manual Deployment","text":"<p>If you need to deploy manually:</p> <pre><code># Activate virtual environment\nsource venv/bin/activate\n\n# Deploy to GitHub Pages\nmkdocs gh-deploy --force\n</code></pre>"},{"location":"DEPLOYMENT/#files","title":"Files","text":"<ul> <li><code>.github/workflows/docs.yml</code> - GitHub Actions workflow</li> <li><code>mkdocs.yml</code> - MkDocs configuration</li> <li><code>docs/</code> - Documentation source files</li> <li><code>site/</code> - Built documentation (generated, not committed)</li> </ul>"},{"location":"combinators/","title":"Combinators","text":"<p>Combinators are higher-order functions that manipulate or combine existing generators (<code>Gen</code>) to create new, more sophisticated generators. They are the primary mechanism in <code>python-proptest</code> for building generators that produce complex data structures, implement specific constraints, or tailor data generation to the precise needs of your tests. Instead of just using basic generators like <code>Gen.int()</code> or <code>Gen.str()</code>, combinators allow you to compose these building blocks into generators for custom objects, lists with specific properties, or data distributions that mimic real-world scenarios. Mastering combinators is key to unlocking the full potential of property-based testing.</p>"},{"location":"combinators/#combinator-summary-table","title":"Combinator Summary Table","text":"Combinator Description Key Parameters Example Usage Selection <code>Gen.one_of(...gens)</code> Randomly picks one generator from <code>gens</code> to produce a value. Use <code>weighted_gen</code> to adjust probabilities. <code>...generators</code> (can be <code>Weighted</code>) <code>Gen.one_of(Gen.int(min_value=0, max_value=10), Gen.int(min_value=20, max_value=30))</code> (Union of ranges) <code>Gen.element_of(...values)</code> Randomly picks one value from the provided <code>values</code>. Use <code>weighted_value</code> to adjust probabilities. <code>...values</code> (can be <code>Weighted</code>) <code>Gen.element_of(2, 3, 5, 7)</code> (Prime numbers &lt; 10) <code>Gen.weighted_gen(gen, weight)</code> Wraps a generator with a <code>weight</code> for <code>Gen.one_of</code>. <code>generator</code>, <code>weight</code> <code>Gen.weighted_gen(Gen.str(), 0.8)</code> (80% probability) <code>Gen.weighted_value(value, weight)</code> Wraps a value with a <code>weight</code> for <code>Gen.element_of</code>. <code>value</code>, <code>weight</code> <code>Gen.weighted_value('a', 0.2)</code> (20% probability) Transformation <code>generator.map(f)</code> Applies function <code>f</code> to each generated value. <code>(value: T) -&gt; U</code> <code>Gen.int(min_value=1, max_value=100).map(lambda n: str(n))</code> (Stringified numbers within [1,100]) <code>generator.filter(predicate)</code> Only keeps values where <code>predicate(value)</code> is true. <code>(value: T) -&gt; bool</code> <code>Gen.int().filter(lambda n: n % 2 == 0)</code> (Even numbers) <code>generator.flat_map(f)</code> / <code>generator.chain(f)</code> Creates a dependent generator using <code>f(value)</code> which returns a new Gen. <code>(value: T) -&gt; Generator[U]</code> <code>Gen.int(min_value=1, max_value=5).flat_map(lambda n: Gen.str(min_length=n))</code> (String of random length within [1,5)) Dependent Generation <code>Gen.chain(base_gen, gen_factory)</code> Creates dependent tuple where next value depends on previous. <code>base_gen</code>, <code>(value) -&gt; Generator</code> <code>Gen.chain(Gen.int(1, 12), lambda m: Gen.int(1, days_in_month(m)))</code> (Valid month/day) <code>Gen.aggregate(initial_gen, gen_factory, ...)</code> Generates list where each element depends on previous. <code>initial_gen</code>, <code>(value) -&gt; Generator</code>, <code>min/max_size</code> <code>Gen.aggregate(Gen.int(0, 10), lambda n: Gen.int(n, n+5), min_size=3)</code> (Increasing list) <code>Gen.accumulate(initial_gen, gen_factory, ...)</code> Generates final value after N dependent steps. <code>initial_gen</code>, <code>(value) -&gt; Generator</code>, <code>min/max_size</code> <code>Gen.accumulate(Gen.int(50, 50), lambda p: Gen.int(max(0,p-10), min(100,p+10)), min_size=10)</code> (Random walk endpoint) Class Construction <code>Gen.construct(Class, ...arg_gens)</code> Creates class instances using <code>Class(...args)</code> from <code>arg_gens</code>. <code>Constructor</code>, <code>...argument_generators</code> <code>Gen.construct(Point, Gen.int(), Gen.int())</code> (Construct Point object)"},{"location":"combinators/#selection-combinators","title":"Selection Combinators","text":""},{"location":"combinators/#genone_ofgenerators","title":"<code>Gen.one_of(*generators)</code>","text":"<p>Randomly chooses one generator from the provided generators to produce a value. Each generator has an equal probability of being selected unless weights are specified.</p> <p>Parameters: - <code>*generators</code> (Generator or Weighted): Variable number of generators, optionally wrapped with <code>Gen.weighted_gen()</code></p> <p>Examples: <pre><code># Equal probability selection\nGen.one_of(\n    Gen.int(min_value=0, max_value=10),\n    Gen.int(min_value=20, max_value=30),\n    Gen.str(min_length=1, max_length=5)\n)\n\n# Weighted selection\nGen.one_of(\n    Gen.weighted_gen(Gen.str(), 0.8),  # 80% probability\n    Gen.weighted_gen(Gen.int(), 0.2)   # 20% probability\n)\n\n# Mixed weighted and unweighted\nGen.one_of(\n    Gen.weighted_gen(Gen.str(), 0.5),  # 50% probability\n    Gen.int(),                         # 25% probability (remaining split)\n    Gen.bool()                         # 25% probability (remaining split)\n)\n</code></pre></p> <p>Use Cases: - Creating union types - Testing multiple data types - Implementing weighted random selection - Creating complex data distributions</p> <p>See Also: <code>Gen.element_of()</code>, <code>Gen.weighted_gen()</code></p>"},{"location":"combinators/#genelement_ofvalues","title":"<code>Gen.element_of(*values)</code>","text":"<p>Randomly chooses one value from the provided values. Each value has an equal probability of being selected unless weights are specified.</p> <p>Parameters: - <code>*values</code> (Any or WeightedValue): Variable number of values, optionally wrapped with <code>Gen.weighted_value()</code></p> <p>Examples: <pre><code># Equal probability selection\nGen.element_of(\"red\", \"green\", \"blue\", \"yellow\")\n\n# Prime numbers\nGen.element_of(2, 3, 5, 7, 11, 13, 17, 19)\n\n# Weighted selection\nGen.element_of(\n    Gen.weighted_value(\"common\", 0.7),    # 70% probability\n    Gen.weighted_value(\"rare\", 0.3)       # 30% probability\n)\n\n# Mixed weighted and unweighted\nGen.element_of(\n    Gen.weighted_value(\"frequent\", 0.6),  # 60% probability\n    \"normal\",                             # 20% probability\n    \"rare\"                                # 20% probability\n)\n</code></pre></p> <p>Use Cases: - Testing enum-like values - Creating categorical data - Implementing weighted choices - Testing specific edge cases</p> <p>See Also: <code>Gen.one_of()</code>, <code>Gen.weighted_value()</code></p>"},{"location":"combinators/#genweighted_gengenerator-weight","title":"<code>Gen.weighted_gen(generator, weight)</code>","text":"<p>Wraps a generator with a weight for use in <code>Gen.one_of()</code>. The weight determines the probability of selecting this generator.</p> <p>Parameters: - <code>generator</code> (Generator): The generator to wrap - <code>weight</code> (float): Probability weight (0.0 to 1.0)</p> <p>Examples: <pre><code># Create weighted generators\ncommon_gen = Gen.weighted_gen(Gen.str(), 0.8)\nrare_gen = Gen.weighted_gen(Gen.int(), 0.2)\n\n# Use in one_of\nGen.one_of(common_gen, rare_gen)\n\n# Multiple weighted generators\nGen.one_of(\n    Gen.weighted_gen(Gen.str(min_length=1, max_length=3), 0.5),\n    Gen.weighted_gen(Gen.int(min_value=1, max_value=10), 0.3),\n    Gen.weighted_gen(Gen.bool(), 0.2)\n)\n</code></pre></p> <p>Use Cases: - Creating realistic data distributions - Testing with biased inputs - Implementing weighted random selection - Simulating real-world scenarios</p> <p>See Also: <code>Gen.one_of()</code>, <code>Gen.weighted_value()</code></p>"},{"location":"combinators/#genweighted_valuevalue-weight","title":"<code>Gen.weighted_value(value, weight)</code>","text":"<p>Wraps a value with a weight for use in <code>Gen.element_of()</code>. The weight determines the probability of selecting this value.</p> <p>Parameters: - <code>value</code> (Any): The value to wrap - <code>weight</code> (float): Probability weight (0.0 to 1.0)</p> <p>Examples: <pre><code># Create weighted values\ncommon_value = Gen.weighted_value(\"success\", 0.9)\nrare_value = Gen.weighted_value(\"error\", 0.1)\n\n# Use in element_of\nGen.element_of(common_value, rare_value)\n\n# Multiple weighted values\nGen.element_of(\n    Gen.weighted_value(\"low\", 0.5),\n    Gen.weighted_value(\"medium\", 0.3),\n    Gen.weighted_value(\"high\", 0.2)\n)\n</code></pre></p> <p>Use Cases: - Creating realistic categorical distributions - Testing with biased inputs - Implementing weighted choices - Simulating real-world scenarios</p> <p>See Also: <code>Gen.element_of()</code>, <code>Gen.weighted_gen()</code></p>"},{"location":"combinators/#transformation-combinators","title":"Transformation Combinators","text":""},{"location":"combinators/#generatormapfunc","title":"<code>generator.map(func)</code>","text":"<p>Transforms each generated value using the provided function. This is one of the most commonly used combinators.</p> <p>Parameters: - <code>func</code> (Callable[[T], U]): Function that transforms a value of type T to type U</p> <p>Examples: <pre><code># Transform integers to strings\nGen.int(min_value=1, max_value=100).map(lambda n: str(n))\n\n# Transform to custom objects\ndef create_user(id_num):\n    return {\"id\": id_num, \"email\": f\"user{id_num}@example.com\"}\n\nGen.int(min_value=1, max_value=1000).map(create_user)\n\n# Transform to tuples\nGen.int().map(lambda x: (x, x * 2, x * 3))\n\n# Transform strings\nGen.str().map(lambda s: s.upper())\n\n# Transform lists\nGen.list(Gen.int()).map(lambda lst: sorted(lst))\n</code></pre></p> <p>Use Cases: - Converting between data types - Creating custom objects - Applying transformations to generated data - Building complex data structures</p> <p>See Also: <code>generator.filter()</code>, <code>generator.flat_map()</code></p>"},{"location":"combinators/#generatorfilterpredicate","title":"<code>generator.filter(predicate)</code>","text":"<p>Only keeps values that satisfy the given predicate function. Be cautious with restrictive predicates as they can slow down generation.</p> <p>Parameters: - <code>predicate</code> (Callable[[T], bool]): Function that returns True for values to keep</p> <p>Examples: <pre><code># Filter even numbers\nGen.int().filter(lambda n: n % 2 == 0)\n\n# Filter non-empty strings\nGen.str().filter(lambda s: len(s) &gt; 0)\n\n# Filter positive numbers\nGen.float().filter(lambda x: x &gt; 0)\n\n# Filter lists with specific properties\nGen.list(Gen.int()).filter(lambda lst: len(lst) &gt; 2 and all(x &gt; 0 for x in lst))\n\n# Filter based on multiple conditions\nGen.int().filter(lambda n: n &gt; 0 and n &lt; 100 and n % 3 == 0)\n</code></pre></p> <p>Use Cases: - Restricting value ranges - Testing specific conditions - Creating constrained test data - Implementing business rules</p> <p>Performance Considerations: - Avoid overly restrictive predicates - Consider using <code>Gen.in_range()</code> instead of filtering ranges - Use <code>Gen.one_of()</code> for categorical filtering</p> <p>See Also: <code>generator.map()</code>, <code>generator.flat_map()</code></p>"},{"location":"combinators/#generatorflat_mapfunc","title":"<code>generator.flat_map(func)</code>","text":"<p>Creates a dependent generator where the function takes a generated value and returns a new generator. This is powerful for creating related test data. For more complex dependent generation, consider using <code>Gen.chain()</code>.</p> <p>Parameters: - <code>func</code> (Callable[[T], Generator[U]]): Function that takes a value and returns a generator</p> <p>Examples: <pre><code># Generate string length based on integer\nGen.int(min_value=1, max_value=10).flat_map(\n    lambda length: Gen.str(min_length=length, max_length=length)\n)\n\n# Generate list size based on integer\nGen.int(min_value=1, max_value=5).flat_map(\n    lambda size: Gen.list(Gen.int(), min_length=size, max_length=size)\n)\n\n# Generate dependent values\ndef create_dependent_data(x):\n    if x &gt; 0:\n        return Gen.int(min_value=1, max_value=x)\n    else:\n        return Gen.int(min_value=x, max_value=-1)\n\nGen.int().flat_map(create_dependent_data)\n\n# Generate nested structures\nGen.int(min_value=1, max_value=3).flat_map(\n    lambda depth: Gen.list(\n        Gen.str(min_length=depth, max_length=depth),\n        min_length=depth,\n        max_length=depth\n    )\n)\n</code></pre></p> <p>Use Cases: - Creating dependent test data - Generating related values - Building complex nested structures - Implementing conditional generation</p> <p>See Also: <code>generator.map()</code>, <code>generator.filter()</code>, <code>Gen.chain()</code></p>"},{"location":"combinators/#dependent-generation-combinators","title":"Dependent Generation Combinators","text":"<p>Dependent generation combinators allow you to create generators where subsequent values depend on previously generated values. These are essential for testing stateful systems, sequences with constraints, or data with complex interdependencies.</p> <p>For testing with dependent generators, see the <code>@run_for_all</code> decorator which provides clean syntax for property tests using these combinators.</p>"},{"location":"combinators/#genchainbase_gen-gen_factory-generatorchaingen_factory","title":"<code>Gen.chain(base_gen, gen_factory)</code> / <code>generator.chain(gen_factory)</code>","text":"<p>Creates a tuple generator where the next value depends on the previously generated value(s). The result is always a tuple containing all generated values.</p> <p>Parameters: - <code>base_gen</code> (Generator): Generator for the initial value(s) - can produce single value or tuple - <code>gen_factory</code> (Callable[[T], Generator[U]]): Function that takes the base value and returns a generator</p> <p>Static API Examples: <pre><code># Simple dependency: month -&gt; valid day\ndef days_in_month(month):\n    days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    return days[month - 1]\n\ndate_gen = Gen.chain(\n    Gen.int(1, 12),  # Generate month\n    lambda month: Gen.int(1, days_in_month(month))  # Generate valid day for that month\n)\n# Result: Generator[Tuple[int, int]] producing (month, day) pairs like (2, 28), (12, 31)\n\n# Multiple chaining: month -&gt; day -&gt; hour\ndatetime_gen = Gen.chain(\n    date_gen,  # Base is already a tuple (month, day)\n    lambda date_tuple: Gen.int(0, 23)  # Generate hour\n)\n# Result: Generator[Tuple[int, int, int]] producing (month, day, hour) like (3, 15, 14)\n\n# Width constrains height\nrect_gen = Gen.chain(\n    Gen.int(1, 100),  # Generate width\n    lambda width: Gen.int(1, 200 // width)  # Height constrained by width\n)\n# Result: Generator[Tuple[int, int]] ensuring width * height &lt;= 200\n</code></pre></p> <p>Fluent API Examples: <pre><code># Fluent API style (more concise)\ndate_gen = Gen.int(1, 12).chain(\n    lambda month: Gen.int(1, days_in_month(month))\n)\n\n# Can chain multiple times\ndatetime_gen = Gen.int(1, 12)\\\n    .chain(lambda month: Gen.int(1, days_in_month(month)))\\\n    .chain(lambda date: Gen.int(0, 23))\n</code></pre></p> <p>Use Cases: - Generating valid date combinations (month/day, hour/minute) - Creating dependent geometric properties (width/height with area constraint) - Testing APIs with dependent parameters - Generating valid state transitions - Creating dependent tuple data</p> <p>See Also: <code>Gen.aggregate()</code>, <code>Gen.accumulate()</code>, <code>generator.flat_map()</code>, <code>@run_for_all</code> decorator</p>"},{"location":"combinators/#genaggregateinitial_gen-gen_factory-min_size-max_size-generatoraggregate","title":"<code>Gen.aggregate(initial_gen, gen_factory, min_size, max_size)</code> / <code>generator.aggregate(...)</code>","text":"<p>Generates a list where each element depends on the previous element. Returns the entire sequence of generated values.</p> <p>Parameters: - <code>initial_gen</code> (Generator[T]): Generator for the first element - <code>gen_factory</code> (Callable[[T], Generator[T]]): Function that takes a value and returns a generator for the next value - <code>min_size</code> (int): Minimum number of elements (default: 0) - <code>max_size</code> (int): Maximum number of elements (default: 10)</p> <p>Static API Examples: <pre><code># Increasing sequence: each element &gt;= previous\nincreasing_gen = Gen.aggregate(\n    Gen.int(0, 10),  # Start with 0-10\n    lambda n: Gen.int(n, n + 5),  # Each next value is n to n+5\n    min_size=3,\n    max_size=10\n)\n# Result: [5, 8, 12, 15, 18] - entire sequence of increasing numbers\n\n# Strictly increasing sequence\nstrictly_increasing_gen = Gen.aggregate(\n    Gen.int(0, 5),\n    lambda n: Gen.int(n + 1, n + 10),  # Each next value is &gt; previous\n    min_size=4,\n    max_size=7\n)\n# Result: [2, 5, 8, 15] - each element strictly &gt; previous\n\n# Bounded random walk\nwalk_gen = Gen.aggregate(\n    Gen.int(50, 50),  # Start at position 50\n    lambda pos: Gen.int(max(0, pos - 10), min(100, pos + 10)),  # Move \u00b110\n    min_size=5,\n    max_size=20\n)\n# Result: [50, 45, 52, 48, 38, ...] - random walk staying in [0, 100]\n\n# Growing strings\nstring_growth_gen = Gen.aggregate(\n    Gen.ascii_string(min_length=1, max_length=3),\n    lambda s: Gen.ascii_string(min_length=len(s), max_length=len(s) + 2),\n    min_size=3,\n    max_size=8\n)\n# Result: ['ab', 'abc', 'abcde', 'abcdefg'] - strings growing in length\n</code></pre></p> <p>Fluent API Examples: <pre><code># Fluent style\nincreasing_gen = Gen.int(0, 10).aggregate(\n    lambda n: Gen.int(n, n + 5),\n    min_size=3,\n    max_size=10\n)\n\n# Chain with other combinators\nfiltered_walk = Gen.int(50, 50).aggregate(\n    lambda pos: Gen.int(max(0, pos - 10), min(100, pos + 10)),\n    min_size=10,\n    max_size=20\n).filter(lambda path: path[-1] &gt; 30)  # Only paths ending above 30\n</code></pre></p> <p>Use Cases: - Simulating sequences with constraints (increasing values, bounded movements) - Testing stateful systems where each state depends on previous - Generating time series data - Creating dependency chains - Testing algorithms that process sequences - Simulating random walks or stochastic processes</p> <p>See Also: <code>Gen.chain()</code>, <code>Gen.accumulate()</code>, <code>@run_for_all</code> decorator</p>"},{"location":"combinators/#genaccumulateinitial_gen-gen_factory-min_size-max_size-generatoraccumulate","title":"<code>Gen.accumulate(initial_gen, gen_factory, min_size, max_size)</code> / <code>generator.accumulate(...)</code>","text":"<p>Generates a single final value after N dependent generation steps. Like <code>aggregate</code>, but returns only the end result, not the intermediate values.</p> <p>Parameters: - <code>initial_gen</code> (Generator[T]): Generator for the initial value - <code>gen_factory</code> (Callable[[T], Generator[T]]): Function that takes a value and returns a generator for the next value - <code>min_size</code> (int): Minimum number of accumulation steps (default: 0) - <code>max_size</code> (int): Maximum number of accumulation steps (default: 10)</p> <p>Static API Examples: <pre><code># Random walk - final position only\nfinal_position_gen = Gen.accumulate(\n    Gen.int(0, 100),  # Start position\n    lambda pos: Gen.int(max(0, pos - 5), min(100, pos + 5)),  # Move \u00b15\n    min_size=10,\n    max_size=50\n)\n# Result: 67 - single int (final position after 10-50 steps)\n\n# Compound growth - final amount only\nfinal_amount_gen = Gen.accumulate(\n    Gen.float(100.0, 100.0),  # Start with $100\n    lambda amount: Gen.float(amount * 1.01, amount * 1.1),  # Grow 1-10%\n    min_size=5,\n    max_size=20\n)\n# Result: 156.34 - single float (final amount after compounding)\n\n# Strictly increasing - final value\nfinal_value_gen = Gen.accumulate(\n    Gen.int(0, 10),\n    lambda n: Gen.int(n + 1, n + 5),\n    min_size=10,\n    max_size=15\n)\n# Result: 47 - single int (final value after 10-15 increasing steps)\n</code></pre></p> <p>Fluent API Examples: <pre><code># Fluent style\nfinal_position = Gen.int(50, 50).accumulate(\n    lambda pos: Gen.int(max(0, pos - 10), min(100, pos + 10)),\n    min_size=20,\n    max_size=30\n)\n\n# Use with map\nfinal_state = Gen.int(0, 0).accumulate(\n    lambda state: Gen.int(state, state + 10),\n    min_size=5,\n    max_size=10\n).map(lambda final: f\"Final state: {final}\")\n</code></pre></p> <p>Use Cases: - Testing end states of stochastic processes - Simulating compound growth/decay - Testing final outcomes without intermediate steps - Generating complex derived values - Simulating iterative algorithms (final result only) - Testing convergence properties</p> <p>See Also: <code>Gen.chain()</code>, <code>Gen.aggregate()</code>, <code>@run_for_all</code> decorator</p>"},{"location":"combinators/#comparison-chain-vs-aggregate-vs-accumulate","title":"Comparison: <code>chain</code> vs <code>aggregate</code> vs <code>accumulate</code>","text":"Feature <code>chain</code> <code>aggregate</code> <code>accumulate</code> Returns Tuple of all values List of all values Single final value Dependency Each depends on all previous Each depends on immediate previous Each depends on immediate previous Result Size Fixed (base + 1) Variable (min_size to max_size) Single value Use When Need all related values Need full sequence history Only care about end result Example (month, day, hour) [1, 3, 5, 8, 12] 47 <p>Example Comparison: <pre><code># Chain: Get tuple of related values\ndate = Gen.chain(Gen.int(1, 12), lambda m: Gen.int(1, days_in_month(m)))\n# Result: (3, 15) - tuple of (month, day)\n\n# Aggregate: Get list showing full progression\npath = Gen.aggregate(Gen.int(0, 0), lambda n: Gen.int(n, n+5), min_size=5, max_size=5)\n# Result: [0, 3, 6, 10, 14] - full path shown\n\n# Accumulate: Get only final position\nfinal = Gen.accumulate(Gen.int(0, 0), lambda n: Gen.int(n, n+5), min_size=5, max_size=5)\n# Result: 14 - only final value\n</code></pre></p>"},{"location":"combinators/#class-construction-combinators","title":"Class Construction Combinators","text":""},{"location":"combinators/#genconstructtype-generators","title":"<code>Gen.construct(Type, *generators)</code>","text":"<p>Creates instances of a class using the specified generators for constructor arguments.</p> <p>Parameters: - <code>Type</code> (type): Class to instantiate - <code>*generators</code> (Generator): Generators for constructor arguments</p> <p>Examples: <pre><code># Simple class construction\nclass Point:\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n\nGen.construct(Point, Gen.int(), Gen.int())\n\n# Complex class construction\nclass Person:\n    def __init__(self, name: str, age: int, email: str):\n        self.name = name\n        self.age = age\n        self.email = email\n\nGen.construct(\n    Person,\n    Gen.str(min_length=1, max_length=20),\n    Gen.int(min_value=0, max_value=120),\n    Gen.str(min_length=5, max_length=50)\n)\n\n# Using with other combinators\nclass Rectangle:\n    def __init__(self, width: float, height: float):\n        self.width = width\n        self.height = height\n\nGen.construct(\n    Rectangle,\n    Gen.float(min_value=0.1, max_value=100.0),\n    Gen.float(min_value=0.1, max_value=100.0)\n).filter(lambda rect: rect.width &gt; rect.height)  # Only tall rectangles\n</code></pre></p> <p>Use Cases: - Testing custom classes - Generating domain objects - Creating structured test data - Testing object-oriented code</p> <p>See Also: <code>generator.map()</code>, <code>generator.filter()</code></p>"},{"location":"combinators/#advanced-combinator-patterns","title":"Advanced Combinator Patterns","text":""},{"location":"combinators/#chaining-combinators","title":"Chaining Combinators","text":"<p>Combinators can be chained together to create complex generators. See also the individual combinator documentation: <code>map</code>, <code>filter</code>, <code>flat_map</code>, <code>one_of</code>.</p> <pre><code># Chain multiple transformations\nGen.int(min_value=1, max_value=100)\\\n    .filter(lambda x: x % 2 == 0)\\\n    .map(lambda x: x * 2)\\\n    .map(str)\n\n# Chain with selection\nGen.one_of(\n    Gen.int().filter(lambda x: x &gt; 0),\n    Gen.str().filter(lambda s: len(s) &gt; 0)\n).map(lambda x: f\"Value: {x}\")\n\n# Chain with construction\nGen.construct(\n    Point,\n    Gen.int().filter(lambda x: x &gt; 0),\n    Gen.int().filter(lambda y: y &gt; 0)\n).filter(lambda p: p.x + p.y &gt; 10)\n</code></pre>"},{"location":"combinators/#conditional-generation","title":"Conditional Generation","text":"<p>Use <code>flat_map</code> for conditional generation:</p> <pre><code># Conditional based on value\nGen.int().flat_map(\n    lambda x: Gen.str(min_length=1, max_length=5) if x &gt; 0\n              else Gen.just(\"negative\")\n)\n\n# Conditional based on type\nGen.one_of(Gen.int(), Gen.str()).flat_map(\n    lambda x: Gen.list(Gen.int(), min_length=1, max_length=3) if isinstance(x, int)\n              else Gen.list(Gen.str(), min_length=1, max_length=3)\n)\n</code></pre>"},{"location":"combinators/#recursive-generation","title":"Recursive Generation","text":"<p>Use <code>Gen.lazy()</code> for recursive generators. See also <code>Gen.one_of()</code> and <code>Gen.construct()</code>:</p> <pre><code># Recursive tree structure\ndef tree_gen():\n    return Gen.one_of(\n        Gen.just(None),  # Leaf node\n        Gen.construct(\n            TreeNode,\n            Gen.int(),\n            Gen.lazy(tree_gen),  # Left subtree\n            Gen.lazy(tree_gen)   # Right subtree\n        )\n    )\n\nclass TreeNode:\n    def __init__(self, value, left, right):\n        self.value = value\n        self.left = left\n        self.right = right\n</code></pre>"},{"location":"combinators/#best-practices","title":"Best Practices","text":""},{"location":"combinators/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Avoid overly restrictive filters: Use <code>Gen.in_range()</code> instead of <code>filter</code> for ranges</li> <li>Use appropriate generators: Choose the right generator for your needs (see Generators documentation)</li> <li>Consider weights: Use <code>weighted_gen</code>/<code>weighted_value</code> for realistic distributions</li> <li>Chain efficiently: Order transformations to minimize rejected values</li> </ol>"},{"location":"combinators/#readability-tips","title":"Readability Tips","text":"<ol> <li>Use descriptive names: Name your generators clearly</li> <li>Break down complex generators: Split complex logic into smaller parts</li> <li>Add comments: Explain complex generation logic</li> <li>Use type hints: Help with IDE support and documentation</li> </ol>"},{"location":"combinators/#testing-strategies","title":"Testing Strategies","text":"<ol> <li>Test edge cases: Use <code>Gen.just()</code> for specific values</li> <li>Test realistic data: Use weighted selection for realistic distributions</li> <li>Test boundary conditions: Use <code>Gen.in_range()</code> for boundary testing</li> <li>Test error conditions: Use <code>Gen.element_of()</code> for error cases</li> <li>Test dependent data: Use <code>chain</code>, <code>aggregate</code>, or <code>accumulate</code> for dependent generation</li> </ol> <p>Combinators are the key to creating sophisticated test data that matches your specific needs. By combining and transforming basic generators, you can create generators for any data structure or constraint your tests require. For more information, see:</p> <ul> <li>Generators documentation - Basic generators</li> <li>Decorators documentation - Using generators in tests with <code>@for_all</code> and <code>@run_for_all</code></li> <li>Properties documentation - Writing property-based tests</li> </ul>"},{"location":"decorators/","title":"Decorators","text":"<p>python-proptest provides several decorators to enhance property-based testing with additional features like examples, settings, and matrix testing.</p>"},{"location":"decorators/#overview","title":"Overview","text":"<p>The decorators work together to provide a flexible and powerful testing experience:</p> <ul> <li><code>@for_all</code> - Core property-based testing decorator</li> <li><code>@run_for_all</code> - Versatile decorator for dependent generators</li> <li><code>@example</code> - Provides specific example values to test</li> <li><code>@settings</code> - Configures test parameters like number of runs and seed</li> <li><code>@matrix</code> - Provides exhaustive Cartesian product testing of fixed inputs</li> </ul> <p>For information on generators to use with these decorators, see the Generators documentation.</p>"},{"location":"decorators/#for_all","title":"@for_all","text":"<p>The core decorator for property-based testing. It automatically detects the testing framework (pytest, unittest, or standalone) and adapts accordingly.</p>"},{"location":"decorators/#basic-usage","title":"Basic Usage","text":"<pre><code>from python_proptest import for_all, Gen\n\n@for_all(Gen.int(), Gen.str())\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n    assert len(s) &gt;= 0\n\n# Run the test\ntest_property()\n</code></pre>"},{"location":"decorators/#with-pytest","title":"With pytest","text":"<pre><code>import pytest\nfrom python_proptest import for_all, Gen\n\nclass TestMathProperties:\n    @for_all(Gen.int(), Gen.int())\n    def test_addition_commutativity(self, x: int, y: int):\n        assert x + y == y + x\n</code></pre>"},{"location":"decorators/#with-unittest","title":"With unittest","text":"<pre><code>import unittest\nfrom python_proptest import for_all, Gen\n\nclass TestMathProperties(unittest.TestCase):\n    @for_all(Gen.int(), Gen.int())\n    def test_addition_commutativity(self, x: int, y: int):\n        self.assertEqual(x + y, y + x)\n</code></pre>"},{"location":"decorators/#parameters","title":"Parameters","text":"<ul> <li><code>*generators</code>: Variable number of generators for function arguments</li> <li><code>num_runs</code>: Number of test runs (default: 100)</li> <li><code>seed</code>: Random seed for reproducibility (default: None)</li> </ul> <p>See Also: <code>@run_for_all</code> for dependent generators, <code>@example</code> for specific test cases, <code>@settings</code> for configuration</p>"},{"location":"decorators/#run_for_all","title":"@run_for_all","text":"<p>A versatile decorator that works in three different modes, combining the power of property-based testing with flexible syntax. Unlike <code>@for_all</code>, it doesn't unpack generator values, making it ideal for working with complex generators like <code>chain</code>, <code>aggregate</code>, and <code>accumulate</code>.</p>"},{"location":"decorators/#mode-1-function-call-traditional","title":"Mode 1: Function Call (Traditional)","text":"<p>Use <code>run_for_all</code> as a function to explicitly run property tests:</p> <pre><code>from python_proptest import run_for_all, Gen\n\ndef test_addition():\n    def check(x, y):\n        return x + y == y + x\n\n    result = run_for_all(check, Gen.int(0, 100), Gen.int(0, 100), num_runs=100)\n    assert result is True\n</code></pre>"},{"location":"decorators/#mode-2-test-method-decorator","title":"Mode 2: Test Method Decorator","text":"<p>Decorate test methods to have property tests executed by the test framework:</p> <pre><code>import unittest\nfrom python_proptest import run_for_all, Gen\n\nclass TestProperties(unittest.TestCase):\n    @run_for_all(Gen.int(0, 100), Gen.int(0, 100), num_runs=50)\n    def test_addition_commutative(self, x, y):\n        self.assertEqual(x + y, y + x)\n</code></pre>"},{"location":"decorators/#mode-3-nested-function-decorator-auto-execute","title":"Mode 3: Nested Function Decorator (Auto-Execute)","text":"<p>The most powerful mode - decorate nested functions inside test methods and they execute immediately:</p> <pre><code>import unittest\nfrom python_proptest import run_for_all, Gen\n\nclass TestChain(unittest.TestCase):\n    def test_chain_dependency(self):\n        gen = Gen.chain(Gen.int(1, 10), lambda x: Gen.int(x, x + 10))\n\n        @run_for_all(gen, num_runs=20, seed=42)\n        def check_dependency(pair):\n            base, dependent = pair\n            self.assertGreaterEqual(dependent, base)\n            self.assertLessEqual(dependent, base + 10)\n\n        # No explicit call needed - the property test already ran!\n</code></pre>"},{"location":"decorators/#working-with-complex-generators","title":"Working with Complex Generators","text":"<p><code>@run_for_all</code> is perfect for generators that return tuples or complex structures. For detailed documentation on these combinators, see Dependent Generation Combinators.</p>"},{"location":"decorators/#with-chain","title":"With chain","text":"<p><code>Gen.chain()</code> creates dependent tuples where each value depends on the previous:</p> <pre><code>def test_dependent_generation(self):\n    # chain returns (base_value, dependent_value) tuple\n    gen = Gen.chain(\n        Gen.int(1, 100),\n        lambda x: Gen.int(x, x + 50)\n    )\n\n    @run_for_all(gen, num_runs=50)\n    def check_range(pair):\n        start, end = pair\n        self.assertGreaterEqual(end, start)\n        self.assertLessEqual(end, start + 50)\n</code></pre>"},{"location":"decorators/#with-aggregate","title":"With aggregate","text":"<p><code>Gen.aggregate()</code> generates sequences where each element depends on the previous:</p> <pre><code>def test_increasing_sequence(self):\n    # aggregate returns a list of dependent values\n    gen = Gen.aggregate(\n        Gen.int(0, 10),\n        lambda n: Gen.int(n, n + 5),\n        min_size=5,\n        max_size=10\n    )\n\n    @run_for_all(gen, num_runs=30)\n    def check_sequence(values):\n        self.assertGreaterEqual(len(values), 5)\n        # Check each value &gt;= previous\n        for i in range(1, len(values)):\n            self.assertGreaterEqual(values[i], values[i - 1])\n</code></pre>"},{"location":"decorators/#with-accumulate","title":"With accumulate","text":"<p><code>Gen.accumulate()</code> generates the final value after N dependent steps:</p> <pre><code>def test_final_value(self):\n    # accumulate returns only the final value after N steps\n    gen = Gen.accumulate(\n        Gen.int(10, 20),\n        lambda n: Gen.int(n + 1, n + 5),\n        min_size=10,\n        max_size=10\n    )\n\n    @run_for_all(gen, num_runs=25)\n    def check_final(final_value):\n        # After 10 steps of +1 to +5, should be &gt;= initial + 10\n        self.assertGreaterEqual(final_value, 20)\n</code></pre>"},{"location":"decorators/#comparison-for_all-vs-run_for_all","title":"Comparison: @for_all vs @run_for_all","text":"<pre><code># @for_all unpacks the tuple arguments\n@for_all(Gen.int(1, 10), Gen.int(1, 10))\ndef test_with_for_all(self, x, y):\n    # Gets two separate arguments: x and y\n    assert x &lt;= y\n\n# @run_for_all with chain - receives tuple as-is\n@run_for_all(Gen.chain(Gen.int(1, 10), lambda x: Gen.int(x, x + 10)))\ndef test_with_run_for_all(self, pair):\n    # Gets tuple: (base, dependent)\n    base, dependent = pair\n    assert base &lt;= dependent\n</code></pre>"},{"location":"decorators/#parameters_1","title":"Parameters","text":"<ul> <li><code>*generators</code>: One or more generators (when used as decorator, generators come first)</li> <li><code>num_runs</code>: Number of test runs (default: 100)</li> <li><code>seed</code>: Random seed for reproducibility (default: None)</li> </ul>"},{"location":"decorators/#when-to-use-run_for_all","title":"When to Use @run_for_all","text":"<p>Use <code>@run_for_all</code> when: - Working with <code>chain</code>, <code>aggregate</code>, or <code>accumulate</code> combinators - You want auto-execution in nested function contexts - You prefer explicit control over value unpacking - Testing properties that operate on tuples or complex structures</p> <p>Use <code>@for_all</code> when: - You want automatic argument unpacking - Working with simple, independent generators - Following traditional property testing patterns</p> <p>See Also: <code>@for_all</code>, Dependent Generation Combinators, <code>@settings</code></p>"},{"location":"decorators/#example","title":"@example","text":"<p>Provides specific example values that are tested before random generation. Examples are useful for testing edge cases, known good values, or debugging specific scenarios.</p>"},{"location":"decorators/#basic-usage_1","title":"Basic Usage","text":"<pre><code>from python_proptest import for_all, Gen, example\n\n@for_all(Gen.int(), Gen.str())\n@example(0, \"\")\n@example(42, \"hello\")\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n</code></pre>"},{"location":"decorators/#multiple-examples","title":"Multiple Examples","text":"<pre><code>@for_all(Gen.int(), Gen.str())\n@example(0, \"\")\n@example(1, \"a\")\n@example(-1, \"negative\")\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n</code></pre>"},{"location":"decorators/#examples-with-different-types","title":"Examples with Different Types","text":"<pre><code>@for_all(Gen.int(), Gen.list(Gen.int()))\n@example(0, [])\n@example(1, [1])\n@example(2, [1, 2])\ndef test_list_property(x: int, lst: list):\n    assert isinstance(x, int)\n    assert isinstance(lst, list)\n</code></pre>"},{"location":"decorators/#parameters_2","title":"Parameters","text":"<ul> <li><code>*values</code>: Variable number of values matching the function parameters</li> </ul> <p>See Also: <code>@for_all</code>, <code>@matrix</code>, Best Practices</p>"},{"location":"decorators/#settings","title":"@settings","text":"<p>Configures test parameters like number of runs and random seed. Settings override the defaults provided to <code>@for_all</code>.</p>"},{"location":"decorators/#basic-usage_2","title":"Basic Usage","text":"<pre><code>from python_proptest import for_all, Gen, settings\n\n@for_all(Gen.int(), Gen.str())\n@settings(num_runs=50, seed=42)\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n</code></pre>"},{"location":"decorators/#seed-for-reproducibility","title":"Seed for Reproducibility","text":"<pre><code>@for_all(Gen.int(), Gen.str())\n@settings(seed=\"deterministic\")\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n</code></pre>"},{"location":"decorators/#multiple-settings-last-wins","title":"Multiple Settings (Last Wins)","text":"<pre><code>@for_all(Gen.int(), Gen.str())\n@settings(num_runs=100)\n@settings(seed=42)  # This overrides the previous settings\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n</code></pre>"},{"location":"decorators/#parameters_3","title":"Parameters","text":"<ul> <li><code>num_runs</code>: Number of test runs (overrides @for_all default)</li> <li><code>seed</code>: Random seed for reproducibility (overrides @for_all default)</li> </ul> <p>See Also: <code>@for_all</code>, <code>@run_for_all</code>, Best Practices</p>"},{"location":"decorators/#matrix","title":"@matrix","text":"<p>Provides exhaustive Cartesian product testing of fixed input combinations. Matrix cases are executed once per combination, before examples and random runs, and do not count toward <code>num_runs</code>.</p>"},{"location":"decorators/#basic-usage_3","title":"Basic Usage","text":"<pre><code>from python_proptest import for_all, Gen, matrix\n\n@for_all(Gen.int(), Gen.str())\n@matrix(x=[0, 1], s=[\"a\", \"b\"])\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n</code></pre> <p>This will test all combinations: - <code>(0, \"a\")</code> - <code>(0, \"b\")</code> - <code>(1, \"a\")</code> - <code>(1, \"b\")</code></p>"},{"location":"decorators/#multiple-matrix-decorators","title":"Multiple Matrix Decorators","text":"<pre><code>@for_all(Gen.int(), Gen.str())\n@matrix(x=[0, 1])\n@matrix(s=[\"a\", \"b\"])\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n</code></pre>"},{"location":"decorators/#matrix-with-different-types","title":"Matrix with Different Types","text":"<pre><code>@for_all(Gen.int(), Gen.list(Gen.int()))\n@matrix(x=[0, 1, 2], lst=[[], [1], [1, 2]])\ndef test_property(x: int, lst: list):\n    assert isinstance(x, int)\n    assert isinstance(lst, list)\n</code></pre>"},{"location":"decorators/#matrix-with-complex-types","title":"Matrix with Complex Types","text":"<pre><code>@for_all(Gen.int(), Gen.dict(Gen.str(), Gen.int()))\n@matrix(x=[1, 2], d=[{\"a\": 1}, {\"b\": 2}])\ndef test_property(x: int, d: dict):\n    assert isinstance(x, int)\n    assert isinstance(d, dict)\n</code></pre>"},{"location":"decorators/#parameters_4","title":"Parameters","text":"<ul> <li><code>**kwargs</code>: Named parameters with lists of values to test</li> </ul> <p>See Also: <code>@for_all</code>, <code>@example</code>, Best Practices, Error Handling</p>"},{"location":"decorators/#decorator-composition","title":"Decorator Composition","text":"<p>All decorators can be combined in various ways. The execution order is:</p> <ol> <li>Matrix cases (exhaustive combinations)</li> <li>Example cases (specific values)</li> <li>Random cases (property-based generation)</li> </ol>"},{"location":"decorators/#complete-example","title":"Complete Example","text":"<pre><code>from python_proptest import for_all, Gen, example, settings, matrix\n\n@for_all(Gen.int(), Gen.str())\n@matrix(x=[0, 1], s=[\"a\", \"b\"])  # 4 matrix cases\n@example(42, \"special\")           # 1 example case\n@settings(num_runs=10, seed=42)   # 10 random cases\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n    # Total: 4 + 1 + 10 = 15 test cases\n</code></pre>"},{"location":"decorators/#decorator-order","title":"Decorator Order","text":"<p>The order of decorators matters for merging behavior:</p> <pre><code>@for_all(Gen.int(), Gen.str())\n@matrix(x=[1, 2])      # First matrix decorator\n@matrix(x=[3, 4])      # Second matrix decorator (overwrites first)\n@settings(num_runs=50) # First settings decorator\n@settings(seed=42)     # Second settings decorator (overwrites first)\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n    # Matrix will use x=[3, 4], settings will use seed=42\n</code></pre>"},{"location":"decorators/#integration-with-testing-frameworks","title":"Integration with Testing Frameworks","text":"<p>All decorators work seamlessly with both pytest and unittest:</p>"},{"location":"decorators/#pytest-integration","title":"Pytest Integration","text":"<pre><code>import pytest\nfrom python_proptest import for_all, Gen, example, settings, matrix\n\nclass TestMathProperties:\n    @for_all(Gen.int(), Gen.int())\n    @matrix(x=[0, 1], y=[0, 1])\n    @example(42, 24)\n    @settings(num_runs=50, seed=42)\n    def test_addition_commutativity(self, x: int, y: int):\n        assert x + y == y + x\n</code></pre>"},{"location":"decorators/#unittest-integration","title":"Unittest Integration","text":"<pre><code>import unittest\nfrom python_proptest import for_all, Gen, example, settings, matrix\n\nclass TestMathProperties(unittest.TestCase):\n    @for_all(Gen.int(), Gen.int())\n    @matrix(x=[0, 1], y=[0, 1])\n    @example(42, 24)\n    @settings(num_runs=50, seed=42)\n    def test_addition_commutativity(self, x: int, y: int):\n        self.assertEqual(x + y, y + x)\n</code></pre>"},{"location":"decorators/#programmatic-usage","title":"Programmatic Usage","text":"<p>For programmatic testing, you can use the <code>run_matrix</code> function:</p> <pre><code>from python_proptest import run_matrix\n\ndef test_func(x: int, y: str):\n    assert isinstance(x, int)\n    assert isinstance(y, str)\n\n# Run matrix cases programmatically\nmatrix_spec = {\"x\": [0, 1], \"y\": [\"a\", \"b\"]}\nrun_matrix(test_func, matrix_spec)\n</code></pre>"},{"location":"decorators/#parameters_5","title":"Parameters","text":"<ul> <li><code>test_func</code>: Function to test</li> <li><code>matrix_spec</code>: Dictionary mapping parameter names to lists of values</li> <li><code>self_obj</code>: Optional self object for class methods</li> </ul>"},{"location":"decorators/#best-practices","title":"Best Practices","text":""},{"location":"decorators/#1-use-examples-for-edge-cases","title":"1. Use Examples for Edge Cases","text":"<p>Combine <code>@example</code> with <code>@for_all</code> to test specific edge cases before random generation:</p> <pre><code>@for_all(Gen.int())\n@example(0)      # Edge case: zero\n@example(1)      # Edge case: one\n@example(-1)     # Edge case: negative\ndef test_property(x: int):\n    assert isinstance(x, int)\n</code></pre>"},{"location":"decorators/#2-use-matrix-for-exhaustive-testing","title":"2. Use Matrix for Exhaustive Testing","text":"<p>Use <code>@matrix</code> to test all combinations of important values:</p> <pre><code>@for_all(Gen.int(), Gen.int())\n@matrix(x=[0, 1, -1], y=[0, 1, -1])  # Test all combinations of edge cases\ndef test_property(x: int, y: int):\n    assert isinstance(x, int)\n    assert isinstance(y, int)\n</code></pre>"},{"location":"decorators/#3-use-settings-for-reproducibility","title":"3. Use Settings for Reproducibility","text":"<p>Use <code>@settings</code> to ensure tests are reproducible:</p> <pre><code>@for_all(Gen.int(), Gen.str())\n@settings(seed=42)  # Reproducible tests\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n</code></pre>"},{"location":"decorators/#4-combine-decorators-strategically","title":"4. Combine Decorators Strategically","text":"<p>Combine <code>@for_all</code>, <code>@matrix</code>, <code>@example</code>, and <code>@settings</code> for comprehensive testing. See also Decorator Composition.</p> <pre><code>@for_all(Gen.int(), Gen.str())\n@matrix(x=[0, 1], s=[\"a\", \"b\"])  # Exhaustive edge cases\n@example(42, \"special\")          # Known good value\n@settings(num_runs=100, seed=42) # Reproducible random testing\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n</code></pre> <p>See Also: Decorator Composition, Decorator Order</p>"},{"location":"decorators/#error-handling","title":"Error Handling","text":""},{"location":"decorators/#matrix-parameter-coverage","title":"Matrix Parameter Coverage","text":"<p>Matrix decorators require all function parameters to be covered:</p> <pre><code>@for_all(Gen.int(), Gen.str())\n@matrix(x=[0, 1])  # Missing 's' parameter - matrix cases will be skipped\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n</code></pre>"},{"location":"decorators/#example-parameter-count","title":"Example Parameter Count","text":"<p>Example decorators must provide the correct number of arguments:</p> <pre><code>@for_all(Gen.int(), Gen.str())\n@example(42)  # Missing second argument - example will be skipped\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n</code></pre>"},{"location":"decorators/#settings-override","title":"Settings Override","text":"<p>Later settings decorators override earlier ones:</p> <pre><code>@for_all(Gen.int(), Gen.str())\n@settings(num_runs=100, seed=1)\n@settings(num_runs=50, seed=2)  # Only seed=2 will be used\ndef test_property(x: int, s: str):\n    assert isinstance(x, int)\n    assert isinstance(s, str)\n</code></pre>"},{"location":"decorators/#related-documentation","title":"Related Documentation","text":"<ul> <li>Generators - Available generators for creating test data</li> <li>Combinators - Combining and transforming generators</li> <li>Properties - Alternative approaches to property testing</li> <li>Pytest Integration - Using decorators with pytest</li> <li>Unittest Integration - Using decorators with unittest</li> </ul>"},{"location":"generators/","title":"Generators","text":"<p>Generators are the foundation of property-based testing in <code>python-proptest</code>. They are responsible for creating the diverse range of random (or sometimes specific) input data that is fed into your properties during testing. By defining how data should be generated \u2013 its type, constraints, and structure \u2013 generators allow <code>python-proptest</code> to explore the input space of your functions effectively, searching for edge cases and potential bugs that manually chosen examples might miss. Generators can range from simple primitives like booleans and numbers to complex, nested data structures built by combining other generators.</p>"},{"location":"generators/#generator-summary-table","title":"Generator Summary Table","text":"Generator Description Key Parameters Example Usage Primitives <code>Gen.bool()</code> Generates <code>True</code> or <code>False</code> with configurable probability. <code>true_prob</code> (def: 0.5) <code>Gen.bool(true_prob=0.8)</code> <code>Gen.float()</code> Generates floating-point numbers (incl. <code>inf</code>, <code>-inf</code>, <code>nan</code>). <code>min_value</code>, <code>max_value</code> <code>Gen.float(min_value=0.0, max_value=1.0)</code> <code>Gen.int()</code> Generates integers in the range <code>[min_value, max_value]</code>. <code>min_value</code>, <code>max_value</code> <code>Gen.int(min_value=0, max_value=10)</code> <code>Gen.str()</code> Generates strings (defaults to ASCII). <code>min_length</code> (def: 0), <code>max_length</code> (def: 10) <code>Gen.str(min_length=0, max_length=5)</code> <code>Gen.ascii_string(...)</code> Generates strings containing only ASCII chars (0-127). <code>min_length</code> (def: 0), <code>max_length</code> (def: 10) <code>Gen.ascii_string(min_length=1, max_length=8)</code> <code>Gen.unicode_string(...)</code> Generates strings containing Unicode chars. <code>min_length</code> (def: 0), <code>max_length</code> (def: 10) <code>Gen.unicode_string(min_length=1, max_length=8)</code> <code>Gen.printable_ascii_string(...)</code> Generates strings containing only printable ASCII chars. <code>min_length</code> (def: 0), <code>max_length</code> (def: 10) <code>Gen.printable_ascii_string(min_length=5, max_length=5)</code> <code>Gen.ascii_char()</code> Generates ASCII character codes (0-127). None <code>Gen.ascii_char()</code> <code>Gen.unicode_char()</code> Generates Unicode character codes (avoiding surrogate pairs). None <code>Gen.unicode_char()</code> <code>Gen.printable_ascii_char()</code> Generates printable ASCII character codes (32-126). None <code>Gen.printable_ascii_char()</code> <code>Gen.in_range(min, max)</code> Generates integers in range [min, max) (exclusive). <code>min_value</code>, <code>max_value</code> <code>Gen.in_range(0, 10)</code> <code>Gen.unique_list(elem, ...)</code> Generates lists with unique elements, sorted. <code>element_gen</code>, <code>min_length</code> (def: 0), <code>max_length</code> (def: 10) <code>Gen.unique_list(Gen.int(min_value=1, max_value=5), min_length=1, max_length=3)</code> Containers <code>Gen.list(elem, ...)</code> Generates lists with elements from <code>elem</code>. <code>element_gen</code>, <code>min_length</code> (def: 0), <code>max_length</code> (def: 10) <code>Gen.list(Gen.bool(), min_length=2, max_length=4)</code> <code>Gen.set(elem, ...)</code> Generates <code>set</code> objects with elements from <code>elem</code>. <code>element_gen</code>, <code>min_size</code> (def: 0), <code>max_size</code> (def: 10) <code>Gen.set(Gen.int(min_value=1, max_value=3), min_size=1, max_size=3)</code> <code>Gen.dict(key_gen, val_gen, ...)</code> Generates dictionaries with keys from <code>key_gen</code> and values from <code>val_gen</code>. <code>key_gen</code>, <code>value_gen</code>, <code>min_size</code> (def: 0), <code>max_size</code> (def: 10) <code>Gen.dict(Gen.str(min_length=1, max_length=2), Gen.int(min_value=0, max_value=5), min_size=2, max_size=5)</code> <code>Gen.tuple(...gens)</code> Generates fixed-size tuples from <code>gens</code>. <code>...element_gens</code> <code>Gen.tuple(Gen.float(), Gen.str())</code> Special <code>Gen.just(value)</code> Always generates the provided <code>value</code>. <code>value</code> <code>Gen.just(None)</code> <code>Gen.lazy(value_factory)</code> Defers execution of a function to produce <code>value</code> until needed. <code>value_factory: Callable[[], T]</code> <code>Gen.lazy(lambda: expensive_calculation())</code> <p>(Defaults for length/size are typically 0 and 10, but check implementation for specifics)</p>"},{"location":"generators/#primitive-generators","title":"Primitive Generators","text":""},{"location":"generators/#genintmin_value-max_value","title":"<code>Gen.int(min_value, max_value)</code>","text":"<p>Generates random integers within the specified range (inclusive).</p> <p>Parameters: - <code>min_value</code> (int, default: -1000): Minimum integer value to generate - <code>max_value</code> (int, default: 1000): Maximum integer value to generate</p> <p>Examples: <pre><code># Generate integers from 0 to 100\nGen.int(min_value=0, max_value=100)\n\n# Generate negative integers\nGen.int(min_value=-50, max_value=-1)\n\n# Generate single value (when min_value == max_value)\nGen.int(min_value=42, max_value=42)\n</code></pre></p> <p>Use Cases: - Testing mathematical operations - Generating array indices - Creating test IDs or counts</p> <p>See Also: <code>Gen.in_range()</code>, <code>Gen.interval()</code>, <code>Gen.float()</code></p>"},{"location":"generators/#genfloatmin_value-max_value","title":"<code>Gen.float(min_value, max_value)</code>","text":"<p>Generates random floating-point numbers within the specified range.</p> <p>Parameters: - <code>min_value</code> (float, default: -1000.0): Minimum float value to generate - <code>max_value</code> (float, default: 1000.0): Maximum float value to generate</p> <p>Examples: <pre><code># Generate floats from 0.0 to 1.0\nGen.float(min_value=0.0, max_value=1.0)\n\n# Generate negative floats\nGen.float(min_value=-10.0, max_value=-0.1)\n\n# Generate very small floats\nGen.float(min_value=0.0, max_value=0.001)\n</code></pre></p> <p>Use Cases: - Testing floating-point arithmetic - Generating probabilities or percentages - Creating test measurements or coordinates</p> <p>See Also: <code>Gen.int()</code>, <code>Gen.bool()</code></p>"},{"location":"generators/#genbooltrue_prob","title":"<code>Gen.bool(true_prob)</code>","text":"<p>Generates random boolean values (<code>True</code> or <code>False</code>) with configurable probability.</p> <p>Parameters: - <code>true_prob</code> (float, default: 0.5): Probability of generating <code>True</code> (0.0 to 1.0)</p> <p>Examples: <pre><code># Generate random booleans (50% True, 50% False)\nGen.bool()\n\n# Generate mostly True values (80% True, 20% False)\nGen.bool(true_prob=0.8)\n\n# Generate mostly False values (10% True, 90% False)\nGen.bool(true_prob=0.1)\n\n# Always generate True\nGen.bool(true_prob=1.0)\n\n# Always generate False\nGen.bool(true_prob=0.0)\n\n# Use with other generators\nGen.tuple(Gen.bool(true_prob=0.7), Gen.int())\n\n# Generate lists of biased booleans\nGen.list(Gen.bool(true_prob=0.3), min_length=1, max_length=5)\n</code></pre></p> <p>Use Cases: - Testing conditional logic with biased inputs - Generating feature flags with realistic distributions - Creating binary choices with weighted probabilities - Testing boolean operations with edge cases - Simulating real-world boolean distributions</p> <p>See Also: <code>Gen.just()</code> for constant values, <code>Gen.list()</code> for lists of booleans</p>"},{"location":"generators/#genstrmin_length-max_length","title":"<code>Gen.str(min_length, max_length)</code>","text":"<p>Generates random strings with ASCII characters.</p> <p>Parameters: - <code>min_length</code> (int, default: 0): Minimum string length - <code>max_length</code> (int, default: 20): Maximum string length</p> <p>Examples: <pre><code># Generate strings of length 5 to 10\nGen.str(min_length=5, max_length=10)\n\n# Generate single character strings\nGen.str(min_length=1, max_length=1)\n\n# Generate empty strings (min_length=0)\nGen.str(min_length=0, max_length=0)\n</code></pre></p> <p>Use Cases: - Testing string operations - Generating usernames or identifiers - Creating test data for text processing</p> <p>See Also: <code>Gen.ascii_string()</code>, <code>Gen.unicode_string()</code>, <code>Gen.printable_ascii_string()</code></p>"},{"location":"generators/#genascii_stringmin_length-max_length","title":"<code>Gen.ascii_string(min_length, max_length)</code>","text":"<p>Generates random strings containing only ASCII characters (0-127).</p> <p>Parameters: - <code>min_length</code> (int, default: 0): Minimum string length - <code>max_length</code> (int, default: 20): Maximum string length</p> <p>Examples: <pre><code># Generate ASCII strings of length 1 to 8\nGen.ascii_string(min_length=1, max_length=8)\n\n# Generate fixed-length ASCII strings\nGen.ascii_string(min_length=5, max_length=5)\n</code></pre></p> <p>Use Cases: - Testing ASCII-only systems - Generating legacy-compatible strings - Creating test data for systems with ASCII restrictions</p> <p>See Also: <code>Gen.str()</code>, <code>Gen.printable_ascii_string()</code>, <code>Gen.ascii_char()</code></p>"},{"location":"generators/#genprintable_ascii_stringmin_length-max_length","title":"<code>Gen.printable_ascii_string(min_length, max_length)</code>","text":"<p>Generates random strings containing only printable ASCII characters (32-126).</p> <p>Parameters: - <code>min_length</code> (int, default: 0): Minimum string length - <code>max_length</code> (int, default: 20): Maximum string length</p> <p>Examples: <pre><code># Generate printable ASCII strings\nGen.printable_ascii_string(min_length=1, max_length=10)\n\n# Generate fixed-length printable strings\nGen.printable_ascii_string(min_length=5, max_length=5)\n</code></pre></p> <p>Use Cases: - Testing user input validation - Generating displayable text - Creating test data for human-readable strings</p> <p>See Also: <code>Gen.ascii_string()</code>, <code>Gen.printable_ascii_char()</code></p>"},{"location":"generators/#genunicode_stringmin_length-max_length","title":"<code>Gen.unicode_string(min_length, max_length)</code>","text":"<p>Generates random strings containing Unicode characters.</p> <p>Parameters: - <code>min_length</code> (int, default: 0): Minimum string length - <code>max_length</code> (int, default: 20): Maximum string length</p> <p>Examples: <pre><code># Generate Unicode strings\nGen.unicode_string(min_length=1, max_length=10)\n\n# Generate short Unicode strings\nGen.unicode_string(min_length=1, max_length=3)\n</code></pre></p> <p>Use Cases: - Testing internationalization - Generating multi-language text - Creating test data for Unicode-aware systems</p> <p>See Also: <code>Gen.str()</code>, <code>Gen.unicode_char()</code></p>"},{"location":"generators/#genascii_char","title":"<code>Gen.ascii_char()</code>","text":"<p>Generates single ASCII character codes (0-127).</p> <p>Parameters: - None</p> <p>Examples: <pre><code># Generate ASCII character codes\nGen.ascii_char()\n\n# Use with map to get actual characters\nGen.ascii_char().map(chr)\n</code></pre></p> <p>Use Cases: - Testing character processing - Generating single character inputs - Creating test data for character-based operations</p> <p>See Also: <code>Gen.ascii_string()</code>, <code>Gen.unicode_char()</code>, <code>Gen.printable_ascii_char()</code>, <code>generator.map()</code></p>"},{"location":"generators/#genunicode_char","title":"<code>Gen.unicode_char()</code>","text":"<p>Generates single Unicode character codes (avoiding surrogate pairs).</p> <p>Parameters: - None</p> <p>Examples: <pre><code># Generate Unicode character codes\nGen.unicode_char()\n\n# Use with map to get actual characters\nGen.unicode_char().map(chr)\n</code></pre></p> <p>Use Cases: - Testing Unicode character handling - Generating international characters - Creating test data for Unicode-aware systems</p> <p>See Also: <code>Gen.unicode_string()</code>, <code>Gen.ascii_char()</code>, <code>generator.map()</code></p>"},{"location":"generators/#genprintable_ascii_char","title":"<code>Gen.printable_ascii_char()</code>","text":"<p>Generates single printable ASCII character codes (32-126).</p> <p>Parameters: - None</p> <p>Examples: <pre><code># Generate printable ASCII character codes\nGen.printable_ascii_char()\n\n# Use with map to get actual characters\nGen.printable_ascii_char().map(chr)\n</code></pre></p> <p>Use Cases: - Testing printable character processing - Generating displayable characters - Creating test data for user-visible text</p> <p>See Also: <code>Gen.printable_ascii_string()</code>, <code>Gen.ascii_char()</code>, <code>generator.map()</code></p>"},{"location":"generators/#genin_rangemin_value-max_value","title":"<code>Gen.in_range(min_value, max_value)</code>","text":"<p>Generates random integers in range [min_value, max_value) (exclusive of max_value).</p> <p>Parameters: - <code>min_value</code> (int): Minimum integer value (inclusive) - <code>max_value</code> (int): Maximum integer value (exclusive)</p> <p>Examples: <pre><code># Generate integers from 0 to 9 (exclusive of 10)\nGen.in_range(0, 10)\n\n# Generate array indices\nGen.in_range(0, len(my_array))\n</code></pre></p> <p>Use Cases: - Generating array indices - Creating ranges for iteration - Testing boundary conditions</p> <p>See Also: <code>Gen.int()</code>, <code>Gen.interval()</code></p>"},{"location":"generators/#genintervalmin_value-max_value","title":"<code>Gen.interval(min_value, max_value)</code>","text":"<p>Generates random integers in range [min_value, max_value] (inclusive of both bounds).</p> <p>Parameters: - <code>min_value</code> (int): Minimum integer value (inclusive) - <code>max_value</code> (int): Maximum integer value (inclusive)</p> <p>Examples: <pre><code># Generate integers from 0 to 10 (inclusive)\nGen.interval(0, 10)\n\n# Generate dice rolls (1 to 6)\nGen.interval(1, 6)\n</code></pre></p> <p>Use Cases: - Testing inclusive ranges - Generating dice rolls or random selections - Creating bounded integer values</p> <p>See Also: <code>Gen.int()</code>, <code>Gen.in_range()</code>, <code>Gen.integers()</code></p>"},{"location":"generators/#genintegersmin_value-max_value","title":"<code>Gen.integers(min_value, max_value)</code>","text":"<p>Alias for <code>Gen.interval()</code> for compatibility.</p> <p>Parameters: - <code>min_value</code> (int): Minimum integer value (inclusive) - <code>max_value</code> (int): Maximum integer value (inclusive)</p> <p>Examples: <pre><code># Same as Gen.interval(0, 10)\nGen.integers(0, 10)\n</code></pre></p>"},{"location":"generators/#container-generators","title":"Container Generators","text":""},{"location":"generators/#genlistelement_gen-min_length-max_length","title":"<code>Gen.list(element_gen, min_length, max_length)</code>","text":"<p>Generates random lists with elements from the specified generator.</p> <p>Parameters: - <code>element_gen</code> (Generator): Generator for list elements - <code>min_length</code> (int, default: 0): Minimum list length - <code>max_length</code> (int, default: 10): Maximum list length</p> <p>Examples: <pre><code># Generate lists of 2 to 5 booleans\nGen.list(Gen.bool(), min_length=2, max_length=5)\n\n# Generate lists of integers\nGen.list(Gen.int(min_value=1, max_value=100), min_length=0, max_length=10)\n\n# Generate lists of strings\nGen.list(Gen.str(min_length=1, max_length=5), min_length=1, max_length=3)\n</code></pre></p> <p>Use Cases: - Testing list operations - Generating test data collections - Creating sequences for processing</p> <p>See Also: <code>Gen.unique_list()</code>, <code>Gen.set()</code>, <code>Gen.tuple()</code>, <code>generator.map()</code></p>"},{"location":"generators/#genunique_listelement_gen-min_length-max_length","title":"<code>Gen.unique_list(element_gen, min_length, max_length)</code>","text":"<p>Generates random lists with unique elements, sorted.</p> <p>Parameters: - <code>element_gen</code> (Generator): Generator for list elements - <code>min_length</code> (int, default: 0): Minimum list length - <code>max_length</code> (int, default: 10): Maximum list length</p> <p>Examples: <pre><code># Generate unique integer lists\nGen.unique_list(Gen.int(min_value=1, max_value=10), min_length=1, max_length=5)\n\n# Generate unique string lists\nGen.unique_list(Gen.str(min_length=1, max_length=3), min_length=2, max_length=4)\n</code></pre></p> <p>Use Cases: - Testing unique value processing - Generating sorted test data - Creating sets represented as lists</p> <p>See Also: <code>Gen.list()</code>, <code>Gen.set()</code></p>"},{"location":"generators/#gensetelement_gen-min_size-max_size","title":"<code>Gen.set(element_gen, min_size, max_size)</code>","text":"<p>Generates random sets with elements from the specified generator.</p> <p>Parameters: - <code>element_gen</code> (Generator): Generator for set elements - <code>min_size</code> (int, default: 0): Minimum set size - <code>max_size</code> (int, default: 10): Maximum set size</p> <p>Examples: <pre><code># Generate sets of integers\nGen.set(Gen.int(min_value=1, max_value=10), min_size=1, max_size=5)\n\n# Generate sets of strings\nGen.set(Gen.str(min_length=1, max_length=3), min_size=2, max_size=4)\n</code></pre></p> <p>Use Cases: - Testing set operations - Generating unique collections - Creating test data for set-based algorithms</p> <p>See Also: <code>Gen.list()</code>, <code>Gen.unique_list()</code></p>"},{"location":"generators/#gendictkey_gen-value_gen-min_size-max_size","title":"<code>Gen.dict(key_gen, value_gen, min_size, max_size)</code>","text":"<p>Generates random dictionaries with keys and values from specified generators.</p> <p>Parameters: - <code>key_gen</code> (Generator): Generator for dictionary keys - <code>value_gen</code> (Generator): Generator for dictionary values - <code>min_size</code> (int, default: 0): Minimum dictionary size - <code>max_size</code> (int, default: 10): Maximum dictionary size</p> <p>Examples: <pre><code># Generate string-to-int dictionaries\nGen.dict(Gen.str(min_length=1, max_length=3), Gen.int(), min_size=1, max_size=5)\n\n# Generate int-to-string dictionaries\nGen.dict(Gen.int(min_value=1, max_value=10), Gen.str(min_length=1, max_length=5))\n</code></pre></p> <p>Use Cases: - Testing dictionary operations - Generating configuration data - Creating test data for key-value processing</p> <p>See Also: <code>Gen.list()</code>, <code>Gen.set()</code>, <code>Gen.tuple()</code></p>"},{"location":"generators/#gentuplegenerators","title":"<code>Gen.tuple(*generators)</code>","text":"<p>Generates fixed-size tuples with elements from the specified generators.</p> <p>Parameters: - <code>*generators</code> (Generator): Variable number of generators for tuple elements</p> <p>Examples: <pre><code># Generate pairs of (bool, int)\nGen.tuple(Gen.bool(), Gen.int())\n\n# Generate triples of (str, int, float)\nGen.tuple(Gen.str(), Gen.int(), Gen.float())\n\n# Generate single-element tuples\nGen.tuple(Gen.str())\n</code></pre></p> <p>Use Cases: - Testing tuple operations - Generating coordinate pairs - Creating structured test data</p> <p>See Also: <code>Gen.list()</code>, <code>Gen.construct()</code>, <code>Gen.chain()</code></p>"},{"location":"generators/#special-generators","title":"Special Generators","text":""},{"location":"generators/#genjustvalue","title":"<code>Gen.just(value)</code>","text":"<p>Always generates the exact value provided.</p> <p>Parameters: - <code>value</code> (Any): The value to always generate</p> <p>Examples: <pre><code># Always generate 42\nGen.just(42)\n\n# Always generate None\nGen.just(None)\n\n# Always generate a specific string\nGen.just(\"hello\")\n</code></pre></p> <p>Use Cases: - Including specific edge cases - Creating constants in test data - Combining with <code>Gen.one_of()</code> for mixed generation</p> <p>See Also: <code>Gen.one_of()</code>, <code>Gen.element_of()</code></p>"},{"location":"generators/#genlazyfunc","title":"<code>Gen.lazy(func)</code>","text":"<p>Defers execution of a function until generation time.</p> <p>Parameters: - <code>func</code> (Callable[[], T]): Function that returns a value when called</p> <p>Examples: <pre><code># Defer expensive calculation\ndef expensive_calculation():\n    return complex_computation()\n\nGen.lazy(expensive_calculation)\n\n# Defer current time\nGen.lazy(lambda: datetime.now())\n</code></pre></p> <p>Use Cases: - Delaying expensive computations - Breaking circular dependencies - Generating time-sensitive values</p> <p>See Also: <code>Gen.construct()</code>, recursive generation patterns in Combinators</p>"},{"location":"generators/#genconstructtype-generators","title":"<code>Gen.construct(Type, *generators)</code>","text":"<p>Creates instances of a class using the specified generators for constructor arguments.</p> <p>Parameters: - <code>Type</code> (type): Class to instantiate - <code>*generators</code> (Generator): Generators for constructor arguments</p> <p>Examples: <pre><code>class Point:\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n\n# Generate Point instances\nGen.construct(Point, Gen.int(), Gen.int())\n\nclass Person:\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n\n# Generate Person instances\nGen.construct(Person, Gen.str(min_length=1, max_length=10), Gen.int(min_value=0, max_value=120))\n</code></pre></p> <p>Use Cases: - Testing custom classes - Generating domain objects - Creating structured test data</p> <p>See Also: <code>Gen.tuple()</code>, <code>Gen.lazy()</code>, <code>Gen.construct()</code> in Combinators</p>"},{"location":"generators/#dependent-generation","title":"Dependent Generation","text":"<p>For generators where values depend on each other, <code>python-proptest</code> provides powerful combinators like <code>chain</code>, <code>aggregate</code>, and <code>accumulate</code>. These are covered in detail in the Combinators documentation under \"Dependent Generation Combinators\".</p> <p>Quick Examples: <pre><code># Chain: Create dependent tuple (month, day)\nGen.chain(Gen.int(1, 12), lambda month: Gen.int(1, days_in_month(month)))\n\n# Aggregate: Create list where each element depends on previous\nGen.aggregate(Gen.int(0, 10), lambda n: Gen.int(n, n + 5), min_size=3, max_size=10)\n\n# Accumulate: Get final value after dependent steps\nGen.accumulate(Gen.int(50, 50), lambda p: Gen.int(max(0, p-10), min(100, p+10)), min_size=10)\n</code></pre></p> <p>See Also: Combinators documentation for transformation combinators (<code>map</code>, <code>filter</code>, <code>flat_map</code>) and Decorators documentation for using generators in tests with <code>@for_all</code> and <code>@run_for_all</code>.</p> <p>Beyond the built-in generators, <code>python-proptest</code> provides combinators: functions that transform or combine existing generators to create new, more complex ones. This is how you build generators for your specific data types and constraints.</p> <p>These combinators are essential tools for tailoring data generation precisely to your testing needs. For a comprehensive guide on how to use them, see the Combinators documentation.</p>"},{"location":"properties/","title":"Properties","text":"<p>Properties define the expected behavior of your code over a range of inputs. For decorator-based approaches, see the Decorators documentation.</p>"},{"location":"properties/#defining-properties-with-property","title":"Defining Properties with <code>Property(...)</code>","text":"<ul> <li> <p><code>Property(predicate: Callable[..., bool | None])</code>: Creates a property object explicitly. The <code>predicate</code> function receives arguments generated according to the generators passed to <code>for_all</code>.</p> <ul> <li>If the predicate returns <code>False</code> or throws an error, the property fails.</li> <li>If the predicate returns <code>True</code> or <code>None</code> (implicitly returns <code>None</code>), the property passes for that input.</li> </ul> <pre><code>from python_proptest import Property, Gen\n\n# Property: The sum of two non-negative numbers is non-negative\ndef sum_property(a: float, b: float):\n    assert a + b &gt;= 0  # Using assertions\n    # Or: return a + b &gt;= 0\n\n# Running the property\nprop = Property(sum_property)\nprop.set_num_runs(200).for_all(Gen.int(min_value=0, max_value=100), Gen.int(min_value=0, max_value=100))\n</code></pre> </li> <li> <p><code>property.set_num_runs(n: int)</code>: Configures the number of random test cases to execute when <code>for_all</code> is called on a <code>Property</code> instance. Returns the <code>Property</code> instance for chaining.</p> </li> <li> <p><code>property.example(...args: Any)</code>: Runs the property's predicate once with the explicitly provided <code>args</code>. Useful for debugging specific edge cases.</p> <pre><code>def prop_func(a: int, b: int):\n    return a &gt; b\n\nprop = Property(prop_func)\nprop.example(5, 3)  # Runs the predicate with a=5, b=3\nprop.example(3, 5)  # returns False\n</code></pre> </li> </ul> <p>See Also: <code>run_for_all()</code>, <code>@for_all</code> decorator</p>"},{"location":"properties/#defining-and-running-properties-with-run_for_all-lambda-based","title":"Defining and Running Properties with <code>run_for_all(...)</code> (Lambda-Based)","text":"<ul> <li> <p><code>run_for_all(predicate: Callable[..., bool | None], *generators: Generator[Any])</code>: Suitable for simple property checks that can be expressed as lambdas. This is a concise way to define and immediately check a property. It implicitly creates and runs the property. You don't need to manually create a <code>Property</code> object.</p> <pre><code>from python_proptest import run_for_all, Gen\n\n# Property: Reversing a list twice yields the original list\ndef test_double_reverse():\n    def property_func(arr: list):\n        # Predicate using assertions\n        assert list(reversed(list(reversed(arr)))) == arr\n        return True\n\n    run_for_all(property_func, Gen.list(Gen.str(min_length=0, max_length=5), min_length=0, max_length=10))\n\n# Property: String concatenation length\ndef test_string_concatenation_length():\n    def property_func(s1: str, s2: str):\n        # Predicate returning a boolean\n        return len(s1 + s2) == len(s1) + len(s2)\n\n    run_for_all(property_func, Gen.str(min_length=0, max_length=20), Gen.str(min_length=0, max_length=20))\n\n# Property: Absolute value is non-negative\ndef test_absolute_value_non_negative():\n    def property_func(num: float):\n        assert abs(num) &gt;= 0\n        return True\n\n    run_for_all(property_func, Gen.float())  # Use float generator\n\n# Property: Tuple elements follow constraints\ndef test_tuple_constraints():\n    def property_func(tup: tuple):\n        num, bool_val = tup\n        assert num &gt;= 0\n        assert num &lt;= 10\n        assert isinstance(bool_val, bool)\n        return True\n\n    run_for_all(property_func, Gen.tuple(Gen.int(min_value=0, max_value=10), Gen.bool()))\n</code></pre> </li> </ul> <p>See Also: <code>Property()</code>, <code>@run_for_all</code> decorator, Generators</p>"},{"location":"properties/#decorator-based-properties","title":"Decorator-based Properties","text":"<p>python-proptest also supports a decorator-based approach for defining properties, similar to Hypothesis. This is suitable for complex assertions that benefit from explicit parameter signatures. For full documentation, see Decorators.</p> <pre><code>from python_proptest import for_all, integers, text\n\n@for_all(integers(), integers())\ndef test_addition_commutativity(x: int, y: int):\n    \"\"\"Test that addition is commutative.\"\"\"\n    assert x + y == y + x\n\n@for_all(text(), text())\ndef test_string_concatenation(s1: str, s2: str):\n    \"\"\"Test string concatenation properties.\"\"\"\n    result = s1 + s2\n    assert len(result) == len(s1) + len(s2)\n    assert result.startswith(s1)\n    assert result.endswith(s2)\n\n# Run the tests\ntest_addition_commutativity()\ntest_string_concatenation()\n</code></pre>"},{"location":"properties/#choosing-the-right-approach","title":"Choosing the Right Approach","text":"<p>python-proptest provides multiple ways to define property tests. Choose based on your needs:</p>"},{"location":"properties/#use-run_for_all-for-simple-lambda-based-tests","title":"Use <code>run_for_all</code> for Simple Lambda-Based Tests","text":"<p>Suitable for simple property checks that can be expressed as lambdas:</p> <pre><code>from python_proptest import run_for_all, Gen\n\ndef test_simple_properties():\n    # Type checks\n    result = run_for_all(\n        lambda x: isinstance(x, int),\n        Gen.int(min_value=0, max_value=100)\n    )\n\n    # Range validations\n    result = run_for_all(\n        lambda x: 0 &lt;= x &lt;= 100,\n        Gen.int(min_value=0, max_value=100)\n    )\n\n    # Simple assertions\n    result = run_for_all(\n        lambda lst: all(isinstance(x, int) for x in lst),\n        Gen.list(Gen.int())\n    )\n\n    assert result is True\n</code></pre>"},{"location":"properties/#use-for_all-for-complex-function-based-tests","title":"Use <code>@for_all</code> for Complex Function-Based Tests","text":"<p>Suitable for complex assertions that benefit from explicit parameter signatures:</p> <pre><code>from python_proptest import for_all, integers, text\n\n@for_all(integers(), integers())\ndef test_complex_math_property(x: int, y: int):\n    \"\"\"Test complex mathematical property with multiple conditions.\"\"\"\n    result = x * y + x + y\n    assert result &gt;= x\n    assert result &gt;= y\n    assert result % 2 == (x + y) % 2\n\n@for_all(text(), text())\ndef test_string_operations(s1: str, s2: str):\n    \"\"\"Test string operations with multiple assertions.\"\"\"\n    combined = s1 + s2\n    assert len(combined) == len(s1) + len(s2)\n    assert combined.startswith(s1)\n    assert combined.endswith(s2)\n</code></pre>"},{"location":"properties/#guidelines","title":"Guidelines","text":"<ul> <li>Use <code>run_for_all</code> for simple property checks that can be expressed as lambdas</li> <li>Use <code>@for_all</code> for complex assertions that benefit from explicit function signatures</li> <li>Use <code>run_for_all</code> for seed-based reproducibility testing</li> <li>Use <code>@for_all</code> for tests with complex generator transformations</li> <li>Use <code>@run_for_all</code> for dependent generators (<code>chain</code>, <code>aggregate</code>, <code>accumulate</code>)</li> </ul>"},{"location":"properties/#configuration-options","title":"Configuration Options","text":""},{"location":"properties/#number-of-runs","title":"Number of Runs","text":"<pre><code>from python_proptest import Property, Gen\n\ndef my_property(x: int):\n    return x &gt;= 0\n\n# Using Property class\nprop = Property(my_property)\nprop.set_num_runs(500).for_all(Gen.int())\n\n# Using run_for_all with num_runs parameter\nrun_for_all(my_property, Gen.int(), num_runs=500)\n</code></pre>"},{"location":"properties/#seed-for-reproducibility","title":"Seed for Reproducibility","text":"<pre><code>from python_proptest import run_for_all, Gen\n\ndef my_property(x: int):\n    return x &gt;= 0\n\n# Using a fixed seed for reproducible tests\nrun_for_all(my_property, Gen.int(), seed=42)\n\n# Using a string seed\nrun_for_all(my_property, Gen.int(), seed=\"my_test_seed\")\n</code></pre>"},{"location":"properties/#error-handling","title":"Error Handling","text":"<p>When a property fails, python-proptest will:</p> <ol> <li>Report the failure with the original failing input</li> <li>Attempt shrinking to find a minimal counterexample</li> <li>Raise an exception with details about the failure</li> </ol> <pre><code>from python_proptest import run_for_all, Gen, PropertyTestError\n\ndef failing_property(x: int):\n    return x &lt; 100  # This will fail for x &gt;= 100\n\ntry:\n    run_for_all(failing_property, Gen.int())\nexcept PropertyTestError as e:\n    print(f\"Property failed: {e}\")\n    # The error will include the minimal counterexample found through shrinking\n</code></pre>"},{"location":"properties/#best-practices","title":"Best Practices","text":"<ol> <li>Keep properties simple: Each property should test one specific invariant</li> <li>Use meaningful names: Name your properties clearly to understand what they test</li> <li>Handle edge cases: Consider what happens with empty lists, zero values, etc. See <code>@example</code> for testing specific edge cases.</li> <li>Use appropriate generators: Choose generators that match your function's expected input domain</li> <li>Test both positive and negative cases: Verify that your function behaves correctly in both success and failure scenarios</li> <li>Use reproducible seeds: Use <code>@settings(seed=...)</code> for reproducibility</li> </ol> <pre><code># Good: Simple, focused property\ndef test_list_length_after_append():\n    def property_func(lst: list, item: str):\n        original_length = len(lst)\n        lst.append(item)\n        return len(lst) == original_length + 1\n\n    run_for_all(property_func, Gen.list(Gen.str()), Gen.str())\n\n# Good: Testing edge cases\ndef test_division_by_zero():\n    def property_func(a: float, b: float):\n        if b == 0:\n            # Test that division by zero raises an exception\n            try:\n                result = a / b\n                return False  # Should not reach here\n            except ZeroDivisionError:\n                return True  # Expected behavior\n        else:\n            # Test normal division\n            result = a / b\n            return isinstance(result, float)\n\n    run_for_all(property_func, Gen.float(), Gen.float())\n</code></pre>"},{"location":"properties/#related-documentation","title":"Related Documentation","text":"<ul> <li>Decorators - Using <code>@for_all</code>, <code>@run_for_all</code>, <code>@example</code>, <code>@settings</code>, and <code>@matrix</code></li> <li>Generators - Available generators for creating test data</li> <li>Combinators - Combining and transforming generators</li> <li>Shrinking - How python-proptest finds minimal counterexamples</li> </ul>"},{"location":"pytest-best-practices/","title":"Pytest Integration Best Practices","text":"<p>python-proptest provides seamless integration with pytest through the <code>@for_all</code> decorator. This document explains effective approaches for pytest users and why certain patterns work well with pytest's testing model.</p> <p>Note: If you're using unittest, see Unittest Integration for framework-specific guidance. Both pytest and unittest are fully supported with identical functionality.</p>"},{"location":"pytest-best-practices/#effective-approach-nested-property-tests","title":"\u2705 Effective Approach: Nested Property Tests","text":"<p>A reliable and pytest-friendly approach is to nest the property test inside the pytest method:</p> <pre><code>import pytest\nfrom python_proptest import for_all, Gen, integers, text\n\nclass TestMathProperties:\n    \"\"\"Recommended approach: nested property tests.\"\"\"\n\n    def test_addition_commutativity(self):\n        \"\"\"Test that addition is commutative.\"\"\"\n        @for_all(integers(), integers())\n        def test_commutativity(self, x: int, y: int):\n            assert x + y == y + x\n\n        test_commutativity(self)\n\n    def test_multiplication_associativity(self):\n        \"\"\"Test that multiplication is associative.\"\"\"\n        @for_all(integers(), integers(), integers())\n        def test_associativity(self, x: int, y: int, z: int):\n            assert (x * y) * z == x * (y * z)\n\n        test_associativity(self)\n\n    def test_string_properties(self):\n        \"\"\"Test string concatenation properties.\"\"\"\n        @for_all(text(), text())\n        def test_concatenation(self, s1: str, s2: str):\n            combined = s1 + s2\n            assert len(combined) == len(s1) + len(s2)\n            assert combined.startswith(s1)\n            assert combined.endswith(s2)\n\n        test_concatenation(self)\n</code></pre>"},{"location":"pytest-best-practices/#why-this-approach-works-best","title":"Why This Approach Works Best","text":"<ol> <li>No Fixture Conflicts: Pytest doesn't try to inject parameters as fixtures</li> <li>Clear Test Structure: Each pytest method is a clear test case</li> <li>Proper Error Reporting: Failures are reported with clear test method names</li> <li>Pytest Discovery: Works well with pytest's test discovery</li> <li>IDE Support: IDEs can properly identify and run individual tests</li> </ol>"},{"location":"pytest-best-practices/#problematic-approach-direct-method-decoration","title":"\u274c Problematic Approach: Direct Method Decoration","text":"<p>This approach does NOT work due to pytest's fixture injection system:</p> <pre><code># \u274c DON'T DO THIS - Will cause \"fixture not found\" errors\nclass TestMathProperties:\n    @for_all(integers(), integers())\n    def test_addition_commutativity(self, x: int, y: int):\n        assert x + y == y + x\n</code></pre> <p>Why it fails: Pytest tries to inject <code>x</code> and <code>y</code> as fixtures, which don't exist.</p>"},{"location":"pytest-best-practices/#alternative-standalone-functions","title":"\u2705 Alternative: Standalone Functions","text":"<p>For non-class-based tests, you can use standalone functions:</p> <pre><code>from python_proptest import for_all, integers\n\n@for_all(integers(), integers())\ndef test_addition_commutativity(x: int, y: int):\n    \"\"\"Standalone property test.\"\"\"\n    assert x + y == y + x\n\n# Run with: python -m pytest test_file.py::test_addition_commutativity\n</code></pre>"},{"location":"pytest-best-practices/#advanced-patterns","title":"\ud83c\udfaf Advanced Patterns","text":""},{"location":"pytest-best-practices/#multiple-property-tests-in-one-method","title":"Multiple Property Tests in One Method","text":"<pre><code>class TestAdvancedPatterns:\n    def test_multiple_math_properties(self):\n        \"\"\"Test multiple mathematical properties.\"\"\"\n\n        @for_all(integers(), integers())\n        def test_commutativity(self, x: int, y: int):\n            assert x + y == y + x\n\n        @for_all(integers(), integers(), integers())\n        def test_associativity(self, x: int, y: int, z: int):\n            assert (x + y) + z == x + (y + z)\n\n        # Run both property tests\n        test_commutativity(self)\n        test_associativity(self)\n</code></pre>"},{"location":"pytest-best-practices/#conditional-property-tests","title":"Conditional Property Tests","text":"<pre><code>class TestConditionalProperties:\n    def test_division_properties(self):\n        \"\"\"Test division properties with assumptions.\"\"\"\n\n        @for_all(integers(), integers())\n        def test_division_property(self, x: int, y: int):\n            from python_proptest import assume\n            assume(y != 0)  # Skip test cases where y is 0\n            assert (x // y) * y + (x % y) == x\n\n        test_division_property(self)\n</code></pre>"},{"location":"pytest-best-practices/#failing-properties-with-shrinking","title":"Failing Properties with Shrinking","text":"<pre><code>class TestFailingProperties:\n    def test_failing_property_demonstrates_shrinking(self):\n        \"\"\"Test that failing properties show minimal counterexamples.\"\"\"\n\n        @for_all(integers())\n        def test_failing_property(self, x: int):\n            # This will fail for x &gt;= 50\n            assert x &lt; 50\n\n        # This should raise an AssertionError with shrinking information\n        with pytest.raises(AssertionError) as exc_info:\n            test_failing_property(self)\n\n        # The error message should contain failure information\n        error_msg = str(exc_info.value)\n        assert \"Property failed\" in error_msg\n        assert \"run\" in error_msg.lower()\n</code></pre>"},{"location":"pytest-best-practices/#running-tests","title":"\ud83d\ude80 Running Tests","text":""},{"location":"pytest-best-practices/#using-pytest-directly","title":"Using pytest directly","text":"<pre><code># Run all tests in a file\npytest test_file.py -v\n\n# Run specific test class\npytest test_file.py::TestMathProperties -v\n\n# Run specific test method\npytest test_file.py::TestMathProperties::test_addition_commutativity -v\n\n# Run tests matching a pattern\npytest -k \"test_addition\" -v\n</code></pre>"},{"location":"pytest-best-practices/#using-pytest-discovery","title":"Using pytest discovery","text":"<pre><code># Run all tests in the current directory\npytest -v\n\n# Run tests with specific markers\npytest -m \"not slow\" -v\n</code></pre>"},{"location":"pytest-best-practices/#best-practices-summary","title":"\ud83d\udcdd Best Practices Summary","text":"<ol> <li>Use nested property tests inside pytest methods for class-based tests</li> <li>Use standalone functions for simple property tests</li> <li>Keep property tests focused - one property per nested test</li> <li>Use descriptive names for both pytest methods and property functions</li> <li>Handle assumptions with <code>assume()</code> for preconditions</li> <li>Test failing properties to verify shrinking works</li> <li>Use pytest's filtering to run specific tests during development</li> </ol>"},{"location":"pytest-best-practices/#migration-guide","title":"\ud83d\udd27 Migration Guide","text":"<p>If you have existing property tests using other approaches:</p>"},{"location":"pytest-best-practices/#from-direct-decoration-broken","title":"From Direct Decoration (Broken)","text":"<pre><code># \u274c Old broken approach\n@for_all(integers(), integers())\ndef test_commutativity(self, x: int, y: int):\n    assert x + y == y + x\n</code></pre>"},{"location":"pytest-best-practices/#to-nested-approach-effective-for-pytest","title":"To Nested Approach (Effective for pytest)","text":"<pre><code># \u2705 New working approach\ndef test_commutativity(self):\n    @for_all(integers(), integers())\n    def test_commutativity(self, x: int, y: int):\n        assert x + y == y + x\n    test_commutativity(self)\n</code></pre> <p>This approach provides the best balance of pytest integration, clarity, and functionality.</p>"},{"location":"pytest-integration/","title":"Pytest Integration","text":"<p>python-proptest provides seamless integration with pytest through the <code>@for_all</code> decorator. The decorator automatically detects whether it's being used in a pytest context (class methods with <code>self</code> parameter) or standalone functions and adapts accordingly.</p>"},{"location":"pytest-integration/#basic-usage","title":"Basic Usage","text":""},{"location":"pytest-integration/#class-methods-pytest-context-direct-decoration","title":"Class Methods (Pytest Context) - Direct Decoration","text":"<pre><code>import pytest\nfrom python_proptest import for_all, Gen, integers, text\n\nclass TestMathProperties:\n    \"\"\"Test class for mathematical properties.\"\"\"\n\n    @for_all(integers(), integers())\n    def test_addition_commutativity(self, x: int, y: int):\n        \"\"\"Test that addition is commutative - direct decoration.\"\"\"\n        assert x + y == y + x\n\n    @for_all(integers(), integers(), integers())\n    def test_multiplication_associativity(self, x: int, y: int, z: int):\n        \"\"\"Test that multiplication is associative - direct decoration.\"\"\"\n        assert (x * y) * z == x * (y * z)\n</code></pre> <p>\u2705 Direct decoration works. The <code>@for_all</code> decorator automatically detects pytest context and handles the <code>self</code> parameter correctly.</p>"},{"location":"pytest-integration/#alternative-nested-approach-still-supported","title":"Alternative: Nested Approach (Still Supported)","text":"<p>If you prefer the nested approach for clarity, it still works:</p> <pre><code>class TestMathProperties:\n    def test_addition_commutativity(self):\n        \"\"\"Test that addition is commutative - nested approach.\"\"\"\n        @for_all(integers(), integers())\n        def test_commutativity(self, x: int, y: int):\n            assert x + y == y + x\n\n        test_commutativity(self)\n</code></pre>"},{"location":"pytest-integration/#standalone-functions","title":"Standalone Functions","text":"<pre><code>def test_standalone_property():\n    \"\"\"Test that standalone functions work with @for_all.\"\"\"\n    @for_all(integers(), integers())\n    def test_commutativity(x: int, y: int):\n        assert x + y == y + x\n\n    test_commutativity()\n</code></pre>"},{"location":"pytest-integration/#advanced-features","title":"Advanced Features","text":""},{"location":"pytest-integration/#failing-properties-and-shrinking","title":"Failing Properties and Shrinking","text":"<pre><code>class TestFailingProperties:\n    \"\"\"Test class demonstrating failing properties and shrinking.\"\"\"\n\n    def test_failing_property_demonstrates_shrinking(self):\n        \"\"\"Test that failing properties show minimal counterexamples.\"\"\"\n        @for_all(integers())\n        def test_failing_property(self, x: int):\n            # This will fail for x &gt;= 50\n            assert x &lt; 50\n\n        # This should raise an AssertionError with shrinking information\n        with pytest.raises(AssertionError) as exc_info:\n            test_failing_property(self)\n\n        # The error message should contain shrinking information\n        assert \"Property failed\" in str(exc_info.value)\n</code></pre>"},{"location":"pytest-integration/#using-assume-for-preconditions","title":"Using assume() for Preconditions","text":"<pre><code>class TestWithAssumptions:\n    \"\"\"Test class demonstrating assume() functionality.\"\"\"\n\n    def test_with_assume(self):\n        \"\"\"Test assume() functionality in pytest context.\"\"\"\n        @for_all(integers(), integers())\n        def test_with_assume(self, x: int, y: int):\n            from python_proptest import assume\n            assume(y != 0)  # Skip test cases where y is 0\n            # Use a simpler assertion to avoid floating point precision issues\n            assert isinstance(x, int)\n            assert isinstance(y, int)\n\n        test_with_assume(self)\n</code></pre>"},{"location":"pytest-integration/#complex-data-structures","title":"Complex Data Structures","text":"<pre><code>class TestComplexStructures:\n    \"\"\"Test class for complex data structures.\"\"\"\n\n    def test_list_properties(self):\n        \"\"\"Test list properties.\"\"\"\n        @for_all(Gen.list(Gen.int(), min_length=0, max_length=10))\n        def test_list_properties(self, lst: list):\n            original_length = len(lst)\n            lst.append(42)\n            assert len(lst) == original_length + 1\n            assert lst[-1] == 42\n\n        test_list_properties(self)\n\n    def test_string_properties(self):\n        \"\"\"Test string properties.\"\"\"\n        @for_all(text(), text())\n        def test_string_properties(self, s1: str, s2: str):\n            combined = s1 + s2\n            assert len(combined) == len(s1) + len(s2)\n            assert combined.startswith(s1)\n            assert combined.endswith(s2)\n\n        test_string_properties(self)\n</code></pre>"},{"location":"pytest-integration/#running-tests","title":"Running Tests","text":""},{"location":"pytest-integration/#using-pytest-directly","title":"Using pytest directly","text":"<pre><code># Run all tests in a file\npytest test_pytest_integration.py -v\n\n# Run specific test class\npytest test_pytest_integration.py::TestMathProperties -v\n\n# Run specific test method\npytest test_pytest_integration.py::TestMathProperties::test_addition_commutativity -v\n</code></pre>"},{"location":"pytest-integration/#using-pytest-discovery","title":"Using pytest discovery","text":"<pre><code># Run all tests in the current directory\npytest -v\n\n# Run tests matching a pattern\npytest -k \"test_addition\" -v\n\n# Run tests with specific markers\npytest -m \"not slow\" -v\n</code></pre>"},{"location":"pytest-integration/#key-benefits","title":"Key Benefits","text":"<ol> <li>Automatic Detection: The <code>@for_all</code> decorator automatically detects pytest context by checking for <code>self</code> parameter</li> <li>Seamless Integration: Works with pytest's test discovery and execution</li> <li>Proper Error Handling: Failing properties raise <code>AssertionError</code> for seamless pytest integration</li> <li>Shrinking Support: Minimal counterexamples are automatically found and reported</li> <li>Backward Compatibility: Standalone functions continue to work as before</li> </ol>"},{"location":"pytest-integration/#best-practices","title":"Best Practices","text":"<ol> <li>Use descriptive test names: pytest uses test method names for reporting</li> <li>Group related tests: Use test classes to organize related property tests</li> <li>Handle assumptions: Use <code>assume()</code> to skip test cases that don't meet preconditions</li> <li>Test edge cases: Property-based testing is excellent for finding edge cases</li> <li>Use appropriate generators: Choose generators that match your domain</li> </ol>"},{"location":"pytest-integration/#example-complete-test-suite","title":"Example: Complete Test Suite","text":"<pre><code>import pytest\nfrom python_proptest import for_all, Gen, integers, text\n\nclass TestCompleteExample:\n    \"\"\"Complete example of pytest integration.\"\"\"\n\n    def test_basic_math_properties(self):\n        \"\"\"Test basic mathematical properties.\"\"\"\n        @for_all(integers(), integers())\n        def test_commutativity(self, x: int, y: int):\n            assert x + y == y + x\n\n        test_commutativity(self)\n\n    def test_string_operations(self):\n        \"\"\"Test string operation properties.\"\"\"\n        @for_all(text(), text())\n        def test_concatenation(self, s1: str, s2: str):\n            result = s1 + s2\n            assert len(result) == len(s1) + len(s2)\n            assert result.startswith(s1)\n            assert result.endswith(s2)\n\n        test_concatenation(self)\n\n    def test_failing_property(self):\n        \"\"\"Test that failing properties are properly reported.\"\"\"\n        @for_all(integers())\n        def test_failing_property(self, x: int):\n            assert x &lt; 100\n\n        with pytest.raises(AssertionError):\n            test_failing_property(self)\n</code></pre> <p>This integration makes python-proptest a useful tool for property-based testing within the pytest ecosystem, providing the benefits of both frameworks combined.</p>"},{"location":"shrinking/","title":"Shrinking","text":"<p>When <code>run_for_all</code> (either standalone or called on a <code>Property</code> instance) detects a failing test case, it automatically tries to \"shrink\" the failing input to a simpler version that still causes the failure. This helps pinpoint the root cause.</p> <ul> <li>Shrinking explores smaller integers, shorter strings/lists, subsets of sets, and simpler structures based on how the generators were defined and combined.</li> <li>The error message thrown by <code>run_for_all</code> on failure typically includes the original failing input and the final, shrunk failing input.</li> </ul> <pre><code>from python_proptest import run_for_all, Gen, PropertyTestError\n\n# Example where shrinking is useful (using standalone run_for_all)\ndef test_failing_property():\n    # Generator for pairs [a, b] where a &lt;= b\n    pair_gen = Gen.int(min_value=0, max_value=1000).flat_map(\n        lambda a: Gen.tuple(Gen.just(a), Gen.int(min_value=a, max_value=1000))\n    )\n\n    def property_func(tup):\n        # This property fails if the difference is large\n        return tup[1] - tup[0] &lt;= 5\n\n    try:\n        run_for_all(property_func, pair_gen)\n    except PropertyTestError as e:\n        # The error message will likely show a shrunk example,\n        # e.g., \"property failed (simplest args found by shrinking): ...\"\n        print(f\"Property failed: {e}\")\n        # The shrunk example will be much simpler than the original failing input\n</code></pre>"},{"location":"shrinking/#how-shrinking-works","title":"How Shrinking Works","text":"<p>python-proptest's shrinking process follows these principles:</p> <ol> <li> <p>Start with the failing input: When a property fails, the system records the exact input that caused the failure.</p> </li> <li> <p>Generate shrink candidates: For each type of input, python-proptest generates simpler versions:</p> </li> <li>Integers: Shrinks towards 0 (e.g., 100 \u2192 50 \u2192 25 \u2192 12 \u2192 6 \u2192 3 \u2192 1 \u2192 0)</li> <li>Strings: Shrinks by removing characters (e.g., \"hello\" \u2192 \"hell\" \u2192 \"hel\" \u2192 \"he\" \u2192 \"h\" \u2192 \"\")</li> <li>Lists: Shrinks by removing elements and making elements simpler</li> <li> <p>Dictionaries: Shrinks by removing key-value pairs and simplifying values</p> </li> <li> <p>Test each candidate: Each shrink candidate is tested against the property to see if it still fails.</p> </li> <li> <p>Keep the simplest failing case: The shrinking process continues until no simpler input can be found that still causes the failure.</p> </li> </ol>"},{"location":"shrinking/#shrinking-examples","title":"Shrinking Examples","text":""},{"location":"shrinking/#integer-shrinking","title":"Integer Shrinking","text":"<pre><code>from python_proptest import run_for_all, Gen, PropertyTestError\n\ndef test_integer_shrinking():\n    def property_func(x: int):\n        # This will fail for x &gt;= 100\n        return x &lt; 100\n\n    try:\n        run_for_all(property_func, Gen.int(min_value=0, max_value=1000))\n    except PropertyTestError as e:\n        print(f\"Failed with input: {e}\")\n        # The shrunk input will likely be exactly 100, the minimal failing case\n</code></pre>"},{"location":"shrinking/#string-shrinking","title":"String Shrinking","text":"<pre><code>from python_proptest import run_for_all, Gen, PropertyTestError\n\ndef test_string_shrinking():\n    def property_func(s: str):\n        # This will fail for strings containing 'x'\n        return 'x' not in s\n\n    try:\n        run_for_all(property_func, Gen.str(min_length=0, max_length=10))\n    except PropertyTestError as e:\n        print(f\"Failed with input: {e}\")\n        # The shrunk input will likely be just \"x\", the minimal failing case\n</code></pre>"},{"location":"shrinking/#list-shrinking","title":"List Shrinking","text":"<pre><code>from python_proptest import run_for_all, Gen, PropertyTestError\n\ndef test_list_shrinking():\n    def property_func(lst: list):\n        # This will fail for lists with more than 3 elements\n        return len(lst) &lt;= 3\n\n    try:\n        run_for_all(property_func, Gen.list(Gen.int(), min_length=0, max_length=10))\n    except PropertyTestError as e:\n        print(f\"Failed with input: {e}\")\n        # The shrunk input will likely be a list with exactly 4 elements\n</code></pre>"},{"location":"shrinking/#complex-structure-shrinking","title":"Complex Structure Shrinking","text":"<pre><code>from python_proptest import run_for_all, Gen, PropertyTestError\n\ndef test_complex_shrinking():\n    def property_func(data):\n        # This will fail for dictionaries with 'error' key\n        return 'error' not in data\n\n    # Generate complex nested data\n    complex_gen = Gen.dict(\n        Gen.str(min_length=1, max_length=5),\n        Gen.one_of(\n            Gen.str(),\n            Gen.int(),\n            Gen.list(Gen.str(), min_length=0, max_length=3)\n        ),\n        min_size=1,\n        max_size=5\n    )\n\n    try:\n        run_for_all(property_func, complex_gen)\n    except PropertyTestError as e:\n        print(f\"Failed with input: {e}\")\n        # The shrunk input will be the simplest dictionary that still contains 'error'\n</code></pre>"},{"location":"shrinking/#advanced-shrinking","title":"Advanced Shrinking","text":"<p>python-proptest includes advanced shrinking strategies for more complex scenarios:</p>"},{"location":"shrinking/#element-wise-shrinking","title":"Element-wise Shrinking","text":"<p>For collections, python-proptest can shrink individual elements while keeping the structure:</p> <pre><code>from python_proptest import run_for_all, Gen, PropertyTestError\n\ndef test_element_wise_shrinking():\n    def property_func(numbers: list):\n        # This will fail if any number is &gt;= 100\n        return all(n &lt; 100 for n in numbers)\n\n    try:\n        run_for_all(property_func, Gen.list(Gen.int(min_value=0, max_value=200), min_length=1, max_length=5))\n    except PropertyTestError as e:\n        print(f\"Failed with input: {e}\")\n        # The shrunk input will have the minimal number that causes failure\n</code></pre>"},{"location":"shrinking/#membership-wise-shrinking","title":"Membership-wise Shrinking","text":"<p>For sets and dictionaries, python-proptest can remove elements to find the minimal failing subset:</p> <pre><code>from python_proptest import run_for_all, Gen, PropertyTestError\n\ndef test_membership_shrinking():\n    def property_func(items: set):\n        # This will fail if the set contains 42\n        return 42 not in items\n\n    try:\n        run_for_all(property_func, Gen.set(Gen.int(min_value=0, max_value=100), min_size=1, max_size=10))\n    except PropertyTestError as e:\n        print(f\"Failed with input: {e}\")\n        # The shrunk input will likely be just {42}\n</code></pre>"},{"location":"shrinking/#custom-shrinking","title":"Custom Shrinking","text":"<p>You can influence the shrinking behavior by using specific generators or combinators:</p>"},{"location":"shrinking/#using-genjust-for-fixed-values","title":"Using <code>Gen.just()</code> for Fixed Values","text":"<pre><code>from python_proptest import run_for_all, Gen\n\ndef test_with_fixed_values():\n    def property_func(x: int):\n        return x != 42  # This will always fail for x=42\n\n    # Using Gen.just() ensures the value 42 is always generated\n    run_for_all(property_func, Gen.just(42))\n    # The shrunk input will be exactly 42\n</code></pre>"},{"location":"shrinking/#using-genelement_of-for-specific-values","title":"Using <code>Gen.element_of()</code> for Specific Values","text":"<pre><code>from python_proptest import run_for_all, Gen, PropertyTestError\n\ndef test_with_specific_values():\n    def property_func(x: int):\n        return x not in [10, 20, 30]  # This will fail for these values\n\n    try:\n        run_for_all(property_func, Gen.element_of(10, 20, 30, 40, 50))\n    except PropertyTestError as e:\n        print(f\"Failed with input: {e}\")\n        # The shrunk input will be one of the failing values: 10, 20, or 30\n</code></pre>"},{"location":"shrinking/#shrinking-configuration","title":"Shrinking Configuration","text":"<p>You can control shrinking behavior through the <code>Property</code> class:</p> <pre><code>from python_proptest import Property, Gen\n\ndef my_property(x: int):\n    return x &lt; 100\n\n# Create a property with custom shrinking settings\nprop = Property(my_property)\nprop.set_num_runs(100)  # Number of test runs\nprop.for_all(Gen.int(min_value=0, max_value=1000))\n\n# The shrinking process is automatic and cannot be disabled,\n# but you can influence it by choosing appropriate generators\n</code></pre>"},{"location":"shrinking/#best-practices-for-shrinking","title":"Best Practices for Shrinking","text":"<ol> <li> <p>Use appropriate generators: Choose generators that produce values close to the boundaries you want to test.</p> </li> <li> <p>Avoid overly complex predicates: Simple predicates shrink better than complex ones.</p> </li> <li> <p>Test edge cases explicitly: Use <code>Gen.just()</code> or <code>Gen.element_of()</code> to test specific values.</p> </li> <li> <p>Consider the shrinking path: Think about what the minimal failing case should be when designing your properties.</p> </li> </ol> <pre><code># Good: Simple predicate that shrinks well\ndef good_property(x: int):\n    return x &lt; 100\n\n# Less ideal: Complex predicate that might not shrink as effectively\ndef complex_property(x: int):\n    return x &lt; 100 and x % 2 == 0 and x &gt; 0 and str(x).count('1') &lt; 2\n</code></pre> <p>The shrinking process is one of the most powerful features of property-based testing, as it helps you understand exactly what conditions cause your code to fail, making debugging much more effective.</p>"},{"location":"stateful-testing/","title":"Stateful Testing","text":"<p>Stateful testing involves defining a sequence of actions or commands that can be applied to a system under test and verifying properties or invariants about the system's state after executing these sequences.</p> <p><code>python-proptest</code> provides utilities for defining state machines and generating sequences of commands to effectively test stateful systems. It allows you to model the state of your system, define actions that change the state, and automatically run sequences of these actions to find bugs.</p>"},{"location":"stateful-testing/#core-concepts","title":"Core Concepts","text":"<p>Stateful testing in <code>python-proptest</code> revolves around the <code>StatefulProperty</code> class, which orchestrates the test execution. Here are the key components:</p> <ol> <li>Initial State (<code>ObjectType</code>): You need a generator (<code>Generator[ObjectType]</code>) that produces the initial state of the system under test for each test run.</li> <li>Actions (<code>Action</code> or <code>SimpleAction</code>): Actions represent operations that modify the system's state.<ul> <li><code>SimpleAction</code>: Used when you don't need an explicit model. It takes a function <code>(obj: ObjectType) -&gt; None</code>.</li> <li><code>Action</code>: Used when you have a model. It takes a function <code>(obj: ObjectType, model: ModelType) -&gt; None</code> and updates both the real object and the model.</li> </ul> </li> <li>Model (<code>ModelType</code>, Optional): A simplified representation of the system's state. It's used to verify the correctness of the actual system's state after each action.</li> <li>Model Factory (<code>model_factory</code>, Optional): A function <code>(obj: ObjectType) -&gt; ModelType</code> that creates the initial model state based on the initial object state. Required if using a model.</li> <li>Action Generation (<code>action_gen_factory</code> or <code>simple_action_gen_factory</code>): A factory function that returns a generator for the next action based on the current state of the object (and model, if applicable).<ul> <li><code>SimpleActionGenFactory</code>: <code>(obj: ObjectType) -&gt; Generator[SimpleAction[ObjectType]]</code></li> <li><code>ActionGenFactory</code>: <code>(obj: ObjectType, model: ModelType) -&gt; Generator[Action[ObjectType, ModelType]]</code> <code>python-proptest</code> provides helpers like <code>simple_action_gen_of</code> and <code>action_gen_of</code> to combine multiple action generators.</li> </ul> </li> </ol>"},{"location":"stateful-testing/#creating-a-stateful-property","title":"Creating a Stateful Property","text":"<p>You typically use factory functions to create a <code>StatefulProperty</code>:</p> <ul> <li> <p><code>simple_stateful_property&lt;ObjectType&gt;(initial_gen, simple_action_gen_factory)</code>: Use this when you don't need an explicit model. Checks are usually performed within the <code>SimpleAction</code> implementations (e.g., asserting invariants after an operation).</p> <pre><code>from python_proptest import Gen, simple_stateful_property, SimpleAction\nfrom typing import List\n\n# Define the system type\nMySystem = List[int]\n\n# Generator for the initial state (e.g., an empty list)\ninitial_gen = Gen.just([])\n\n# Action: Add an element\ndef add_action_gen():\n    return Gen.int().map(lambda val:\n        SimpleAction(lambda arr: arr.append(val))\n    )\n\n# Action: Clear the list\ndef clear_action_gen():\n    return Gen.just(\n        SimpleAction(lambda arr: arr.clear())\n    )\n\n# Combine action generators\ndef action_factory(obj: MySystem):\n    return Gen.one_of(add_action_gen(), clear_action_gen())\n\n# Create the property\nprop = simple_stateful_property(initial_gen, action_factory)\n\n# Run the test\nprop.go()\n</code></pre> </li> <li> <p><code>stateful_property&lt;ObjectType, ModelType&gt;(initial_gen, model_factory, action_gen_factory)</code>: Use this when you want to maintain a separate model to verify the system's behavior against.</p> <pre><code>from python_proptest import Gen, stateful_property, Action\nfrom typing import List, Dict\n\n# Define the system and model types\nMySystem = List[int]\nMyModel = Dict[str, int]  # Simplified model: {\"count\": int}\n\n# Initial state generator\ninitial_gen = Gen.list(Gen.int(), min_length=0, max_length=10)\n\n# Model factory\ndef model_factory(arr: MySystem) -&gt; MyModel:\n    return {\"count\": len(arr)}\n\n# Action: Add element (updates object and model)\ndef add_action_gen():\n    return Gen.int().map(lambda val:\n        Action(lambda arr, model: (\n            arr.append(val),\n            model.update({\"count\": model[\"count\"] + 1})\n        ))\n    )\n\n# Action: Remove element (updates object and model)\ndef remove_action_gen():\n    return Gen.just(\n        Action(lambda arr, model: (\n            arr.pop() if arr else None,\n            model.update({\"count\": max(0, model[\"count\"] - 1)}) if arr else None\n        ))\n    )\n\n# Action generator factory\ndef action_factory(obj: MySystem, model: MyModel):\n    return Gen.one_of(add_action_gen(), remove_action_gen())\n\n# Create the property\nprop = stateful_property(initial_gen, model_factory, action_factory)\n\n# Run the test\nprop.go()\n</code></pre> </li> </ul>"},{"location":"stateful-testing/#configuration","title":"Configuration","text":"<p>The <code>StatefulProperty</code> instance provides several methods for configuration:</p> <ul> <li><code>set_seed(seed)</code>: Sets the initial seed for the random number generator for reproducible tests.</li> <li><code>set_num_runs(num_runs)</code>: Sets the number of test sequences to execute (default: 100).</li> <li><code>set_min_actions(min_actions)</code> / <code>set_max_actions(max_actions)</code>: Sets the minimum and maximum number of actions per sequence (default: 1-100).</li> <li><code>set_verbosity(verbose)</code>: Enables/disables verbose logging during execution.</li> <li><code>set_on_startup(startup_func)</code>: Sets a function to run before each test sequence.</li> <li><code>set_on_cleanup(cleanup_func)</code>: Sets a function to run after each successful test sequence.</li> <li><code>set_post_check(post_check_func)</code>: Sets a function to run after all actions in a sequence have completed successfully. Useful for final state validation. You can also use <code>set_post_check_without_model((obj: ObjectType) -&gt; None)</code>.</li> </ul> <pre><code>from python_proptest import simple_stateful_property, Gen, SimpleAction\n\ndef test_configured_stateful_property():\n    # Define a simple counter system\n    Counter = int\n\n    # Initial state\n    initial_gen = Gen.just(0)\n\n    # Actions\n    def increment_action():\n        return Gen.just(SimpleAction(lambda counter: counter + 1))\n\n    def decrement_action():\n        return Gen.just(SimpleAction(lambda counter: max(0, counter - 1)))\n\n    def action_factory(counter: Counter):\n        return Gen.one_of(increment_action(), decrement_action())\n\n    # Create and configure the property\n    prop = simple_stateful_property(initial_gen, action_factory)\n    prop.set_seed(42)  # Reproducible tests\n    prop.set_num_runs(50)  # Fewer runs for faster testing\n    prop.set_min_actions(5)  # At least 5 actions per sequence\n    prop.set_max_actions(20)  # At most 20 actions per sequence\n    prop.set_verbosity(True)  # Enable verbose output\n\n    # Add startup and cleanup functions\n    prop.set_on_startup(lambda: print(\"Starting test sequence\"))\n    prop.set_on_cleanup(lambda: print(\"Test sequence completed\"))\n\n    # Add post-check to verify final state\n    prop.set_post_check_without_model(lambda counter: counter &gt;= 0)\n\n    # Run the test\n    prop.go()\n</code></pre>"},{"location":"stateful-testing/#advanced-stateful-testing-examples","title":"Advanced Stateful Testing Examples","text":""},{"location":"stateful-testing/#testing-a-stack-data-structure","title":"Testing a Stack Data Structure","text":"<pre><code>from python_proptest import simple_stateful_property, Gen, SimpleAction\nfrom typing import List\n\ndef test_stack_implementation():\n    # Define the stack system\n    Stack = List[int]\n\n    # Initial state: empty stack\n    initial_gen = Gen.just([])\n\n    # Action: Push an element\n    def push_action():\n        return Gen.int().map(lambda val:\n            SimpleAction(lambda stack: stack.append(val))\n        )\n\n    # Action: Pop an element\n    def pop_action():\n        return Gen.just(\n            SimpleAction(lambda stack: stack.pop() if stack else None)\n        )\n\n    # Action: Peek at the top element\n    def peek_action():\n        return Gen.just(\n            SimpleAction(lambda stack: stack[-1] if stack else None)\n        )\n\n    # Action generator factory\n    def action_factory(stack: Stack):\n        # Only allow pop/peek if stack is not empty\n        if not stack:\n            return push_action()\n        else:\n            return Gen.one_of(push_action(), pop_action(), peek_action())\n\n    # Create the property\n    prop = simple_stateful_property(initial_gen, action_factory)\n    prop.set_post_check_without_model(lambda stack: len(stack) &gt;= 0)\n\n    # Run the test\n    prop.go()\n</code></pre>"},{"location":"stateful-testing/#testing-a-bank-account-with-model","title":"Testing a Bank Account with Model","text":"<pre><code>from python_proptest import stateful_property, Gen, Action\nfrom typing import Dict, Any\n\ndef test_bank_account():\n    # Define the system and model types\n    BankAccount = Dict[str, Any]  # {\"balance\": float, \"transactions\": List[float]}\n    AccountModel = Dict[str, Any]  # {\"balance\": float, \"transaction_count\": int}\n\n    # Initial state generator\n    initial_gen = Gen.dict(\n        Gen.just(\"balance\"),\n        Gen.float(min_value=0.0, max_value=1000.0),\n        min_size=1,\n        max_size=1\n    ).map(lambda d: {**d, \"transactions\": []})\n\n    # Model factory\n    def model_factory(account: BankAccount) -&gt; AccountModel:\n        return {\n            \"balance\": account[\"balance\"],\n            \"transaction_count\": len(account[\"transactions\"])\n        }\n\n    # Action: Deposit money\n    def deposit_action():\n        return Gen.float(min_value=0.01, max_value=100.0).map(lambda amount:\n            Action(lambda account, model: (\n                account.update({\n                    \"balance\": account[\"balance\"] + amount,\n                    \"transactions\": account[\"transactions\"] + [amount]\n                }),\n                model.update({\n                    \"balance\": model[\"balance\"] + amount,\n                    \"transaction_count\": model[\"transaction_count\"] + 1\n                })\n            ))\n        )\n\n    # Action: Withdraw money\n    def withdraw_action():\n        return Gen.float(min_value=0.01, max_value=100.0).map(lambda amount:\n            Action(lambda account, model: (\n                account.update({\n                    \"balance\": max(0, account[\"balance\"] - amount),\n                    \"transactions\": account[\"transactions\"] + [-amount]\n                }),\n                model.update({\n                    \"balance\": max(0, model[\"balance\"] - amount),\n                    \"transaction_count\": model[\"transaction_count\"] + 1\n                })\n            ))\n        )\n\n    # Action generator factory\n    def action_factory(account: BankAccount, model: AccountModel):\n        return Gen.one_of(deposit_action(), withdraw_action())\n\n    # Create the property\n    prop = stateful_property(initial_gen, model_factory, action_factory)\n\n    # Add post-check to verify model consistency\n    def post_check(account: BankAccount, model: AccountModel):\n        assert account[\"balance\"] == model[\"balance\"]\n        assert len(account[\"transactions\"]) == model[\"transaction_count\"]\n        assert account[\"balance\"] &gt;= 0\n\n    prop.set_post_check(post_check)\n    prop.go()\n</code></pre>"},{"location":"stateful-testing/#shrinking-in-stateful-testing","title":"Shrinking in Stateful Testing","text":"<p>If a test sequence fails (an action throws an error or the <code>post_check</code> fails), <code>python-proptest</code> automatically tries to shrink the test case to find a minimal reproduction. It does this by:</p> <ol> <li>Shrinking the Action Sequence: Trying shorter sequences or simpler actions.</li> <li>Shrinking the Initial State: Trying simpler versions of the initial state generated by <code>initial_gen</code>.</li> </ol> <p>The goal is to present the simplest possible initial state and sequence of actions that trigger the failure, making debugging easier. The error message will report the shrunk arguments if successful.</p> <pre><code>from python_proptest import simple_stateful_property, Gen, SimpleAction\n\ndef test_failing_stateful_property():\n    # This will demonstrate shrinking in action\n    Counter = int\n\n    initial_gen = Gen.just(0)\n\n    def increment_action():\n        return Gen.just(SimpleAction(lambda counter: counter + 1))\n\n    def decrement_action():\n        return Gen.just(SimpleAction(lambda counter: counter - 1))\n\n    def action_factory(counter: Counter):\n        return Gen.one_of(increment_action(), decrement_action())\n\n    prop = simple_stateful_property(initial_gen, action_factory)\n\n    # This will fail and show shrinking in action\n    prop.set_post_check_without_model(lambda counter: counter &gt;= 0)\n    prop.go()\n</code></pre> <p>Stateful testing is particularly powerful for testing systems with complex state transitions, concurrent operations, or systems where the order of operations matters. It helps uncover race conditions, state inconsistencies, and other subtle bugs that are difficult to find with traditional unit tests.</p>"},{"location":"unittest-integration/","title":"Unittest Integration","text":"<p>python-proptest provides seamless integration with Python's built-in <code>unittest</code> framework through the <code>@for_all</code> decorator. The decorator automatically detects whether it's being used in a unittest context (unittest.TestCase methods), pytest context, or standalone functions and adapts accordingly.</p> <p>Note: If you're using pytest, see Pytest Integration and Pytest Best Practices for framework-specific guidance. Both pytest and unittest are fully supported with identical functionality.</p>"},{"location":"unittest-integration/#basic-usage","title":"Basic Usage","text":""},{"location":"unittest-integration/#unittest-testcase-methods","title":"Unittest TestCase Methods","text":"<pre><code>import unittest\nfrom python_proptest import for_all, Gen\n\nclass TestMathProperties(unittest.TestCase):\n    \"\"\"Test class for mathematical properties using unittest.\"\"\"\n\n    @for_all(Gen.int(), Gen.int())\n    def test_addition_commutativity(self, x: int, y: int):\n        \"\"\"Test that addition is commutative.\"\"\"\n        result1 = x + y\n        result2 = y + x\n        self.assertEqual(result1, result2)\n\n    @for_all(Gen.int(), Gen.int(), Gen.int())\n    def test_multiplication_associativity(self, x: int, y: int, z: int):\n        \"\"\"Test that multiplication is associative.\"\"\"\n        result1 = (x * y) * z\n        result2 = x * (y * z)\n        self.assertEqual(result1, result2)\n\n    @for_all(Gen.str(), Gen.str())\n    def test_string_concatenation(self, s1: str, s2: str):\n        \"\"\"Test string concatenation properties.\"\"\"\n        result = s1 + s2\n        self.assertEqual(len(result), len(s1) + len(s2))\n        self.assertTrue(result.startswith(s1))\n        self.assertTrue(result.endswith(s2))\n</code></pre> <p>\u2705 Direct decoration works. The <code>@for_all</code> decorator automatically detects unittest context and handles the <code>self</code> parameter correctly.</p>"},{"location":"unittest-integration/#running-unittest-tests","title":"Running Unittest Tests","text":"<pre><code># Run with unittest\npython -m unittest tests.test_unittest_integration -v\n\n# Run with pytest (also works)\npython -m pytest tests/test_unittest_integration.py -v\n</code></pre>"},{"location":"unittest-integration/#advanced-features","title":"Advanced Features","text":""},{"location":"unittest-integration/#mixed-assertion-styles","title":"Mixed Assertion Styles","text":"<p>You can mix unittest assertions with regular assertions in the same test:</p> <pre><code>class TestMixedAssertions(unittest.TestCase):\n    @for_all(Gen.int(), Gen.int())\n    def test_mixed_assertions(self, x: int, y: int):\n        \"\"\"Test mixing different assertion styles.\"\"\"\n        # Unittest assertions\n        self.assertIsInstance(x, int)\n        self.assertIsInstance(y, int)\n\n        # Regular assertions (work in both frameworks)\n        assert x + y == y + x\n        assert x * 0 == 0\n        assert x * 1 == x\n\n        # More unittest assertions\n        self.assertGreaterEqual(x + y, x)\n        self.assertGreaterEqual(x + y, y)\n</code></pre>"},{"location":"unittest-integration/#using-gen-class-directly","title":"Using Gen Class Directly","text":"<pre><code>from python_proptest import for_all, Gen\n\nclass TestWithGen(unittest.TestCase):\n    @for_all(Gen.int(), Gen.str())\n    def test_int_string_properties(self, x: int, s: str):\n        \"\"\"Test properties with int and string generators.\"\"\"\n        self.assertIsInstance(x, int)\n        self.assertIsInstance(s, str)\n        self.assertGreaterEqual(len(s), 0)\n\n    @for_all(Gen.int(min_value=0, max_value=100), Gen.int(min_value=0, max_value=100))\n    def test_positive_int_properties(self, x: int, y: int):\n        \"\"\"Test properties with positive integers.\"\"\"\n        self.assertGreaterEqual(x, 0)\n        self.assertGreaterEqual(y, 0)\n        self.assertGreaterEqual(x + y, x)\n        self.assertGreaterEqual(x + y, y)\n</code></pre>"},{"location":"unittest-integration/#error-handling","title":"Error Handling","text":""},{"location":"unittest-integration/#unittest-specific-error-handling","title":"Unittest-Specific Error Handling","text":"<p>When a property test fails in a unittest context, python-proptest automatically raises the appropriate unittest failure exception:</p> <pre><code>class TestFailingProperties(unittest.TestCase):\n    @for_all(Gen.int(), Gen.int())\n    def test_failing_property(self, x: int, y: int):\n        \"\"\"This test will fail and show proper unittest error reporting.\"\"\"\n        # This will fail for some inputs\n        self.assertLess(x + y, 100)  # Fails when x + y &gt;= 100\n</code></pre> <p>The error will be reported using unittest's standard failure mechanism, making it compatible with unittest's test runners and reporting tools.</p>"},{"location":"unittest-integration/#framework-detection","title":"Framework Detection","text":"<p>python-proptest automatically detects the test framework by checking the class hierarchy:</p> <ol> <li>Unittest Detection: Checks if the class inherits from <code>unittest.TestCase</code></li> <li>Pytest Detection: If not unittest, assumes pytest for class methods with <code>self</code> parameter</li> <li>Standalone Functions: Functions without <code>self</code> parameter are treated as standalone</li> </ol>"},{"location":"unittest-integration/#detection-logic","title":"Detection Logic","text":"<pre><code># The decorator automatically detects:\nclass TestUnittest(unittest.TestCase):  # \u2190 Detected as unittest\n    @for_all(Gen.int())\n    def test_method(self, x: int):\n        self.assertEqual(x, x)\n\nclass TestPytest:  # \u2190 Detected as pytest\n    @for_all(Gen.int())\n    def test_method(self, x: int):\n        assert x == x\n\n@for_all(Gen.int())  # \u2190 Detected as standalone\ndef test_standalone(x: int):\n    assert x == x\n</code></pre>"},{"location":"unittest-integration/#best-practices","title":"Best Practices","text":""},{"location":"unittest-integration/#1-use-descriptive-test-names","title":"1. Use Descriptive Test Names","text":"<pre><code>class TestStringProperties(unittest.TestCase):\n    @for_all(Gen.str(), Gen.str())\n    def test_string_concatenation_length_property(self, s1: str, s2: str):\n        \"\"\"Test that concatenated string length equals sum of individual lengths.\"\"\"\n        result = s1 + s2\n        self.assertEqual(len(result), len(s1) + len(s2))\n</code></pre>"},{"location":"unittest-integration/#2-use-appropriate-assertions","title":"2. Use Appropriate Assertions","text":"<pre><code>class TestNumberProperties(unittest.TestCase):\n    @for_all(integers(min_value=1, max_value=100))\n    def test_positive_number_properties(self, x: int):\n        \"\"\"Test properties of positive numbers.\"\"\"\n        self.assertGreater(x, 0)  # Use unittest assertions\n        self.assertIsInstance(x, int)  # Type checking\n        assert x * 2 &gt; x  # Mix with regular assertions\n</code></pre>"},{"location":"unittest-integration/#3-handle-edge-cases","title":"3. Handle Edge Cases","text":"<pre><code>class TestDivisionProperties(unittest.TestCase):\n    @for_all(Gen.int(), integers(min_value=1, max_value=100))\n    def test_division_properties(self, x: int, y: int):\n        \"\"\"Test division properties with non-zero divisor.\"\"\"\n        quotient = x // y\n        remainder = x % y\n        self.assertEqual(quotient * y + remainder, x)\n        self.assertGreaterEqual(remainder, 0)\n        self.assertLess(remainder, y)\n</code></pre>"},{"location":"unittest-integration/#comparison-with-pytest","title":"Comparison with Pytest","text":"Feature Unittest Pytest Assertions <code>self.assertEqual()</code>, <code>self.assertTrue()</code> <code>assert</code> statements Error Reporting Unittest failure exceptions Pytest assertion rewriting Test Discovery <code>python -m unittest</code> <code>pytest</code> Class Inheritance Must inherit from <code>unittest.TestCase</code> No inheritance required Method Naming Must start with <code>test_</code> Must start with <code>test_</code>"},{"location":"unittest-integration/#migration-from-pytest-to-unittest","title":"Migration from Pytest to Unittest","text":"<p>If you have existing pytest tests and want to migrate to unittest:</p> <pre><code># Before (pytest)\nclass TestMathProperties:\n    @for_all(Gen.int(), Gen.int())\n    def test_addition(self, x: int, y: int):\n        assert x + y == y + x\n\n# After (unittest)\nimport unittest\n\nclass TestMathProperties(unittest.TestCase):\n    @for_all(Gen.int(), Gen.int())\n    def test_addition(self, x: int, y: int):\n        self.assertEqual(x + y, y + x)\n</code></pre> <p>The <code>@for_all</code> decorator works identically in both frameworks - only the assertion style changes.</p>"},{"location":"unittest-integration/#examples","title":"Examples","text":"<p>See the complete examples in: - <code>examples/unittest_pytest_comparison.py</code> - Side-by-side comparison - <code>tests/test_unittest_integration.py</code> - Comprehensive test suite</p>"}]}